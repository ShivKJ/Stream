"""
author: Shiv
email: shivkj001@gmail.com
"""

import operator as op
from collections import Counter, defaultdict
from math import factorial
from operator import attrgetter
from unittest import TestCase, expectedFailure, main

from streamAPI.stream import Stream
from streamAPI.stream.TO import (CollectAndThen, Counting, GroupingBy, Joining, Mapping, Reduce,
                                 Summing, ToList, ToMap, ToSet, on_conflict_do_nothing)
from streamAPI.testHelper import random
from streamAPI.utility import identity


class TOTest(TestCase):
    def test_1(self):
        rnd = random()

        start, end = 1, 100
        size = 1000

        data = rnd.int_range(start, end, size=size)

        # finding frequency of integer numbers generated by random source "rnd".
        # To get this, grouping by elements on their value then collecting them in a list
        # and then finding number of elements in list.
        # For better method see "test_1a"
        element_frequency = Stream(data).collect(GroupingBy(identity,
                                                            CollectAndThen(ToList(), len)))

        out_target = Counter(data)
        self.assertDictEqual(element_frequency, out_target)

    def test_1a(self):
        rnd = random()

        start, end = 1, 100
        size = 1000

        data = rnd.int_range(start, end, size=size)
        element_frequency = Stream(data).collect(GroupingBy(identity, Counting()))

        out_target = Counter(data)
        self.assertDictEqual(element_frequency, out_target)

    def test_2(self):
        rnd = random()

        start, end = 1, 100
        size = 1000

        def mod_10(x): return x % 10

        data = rnd.int_range(start, end, size=size)

        # Grouping elements on the basis of their remainder when dividing them by 10 and then
        # finding distinct elements in each "bucket"
        distinct_elements = Stream(data).collect(GroupingBy(mod_10, ToSet()))

        out_target = defaultdict(set)

        for e in data:
            out_target[mod_10(e)].add(e)

        self.assertDictEqual(distinct_elements, out_target)

    def test_3(self):
        rnd = random()

        start, end = 1, 100
        size = 1000

        def mod_10(x): return x % 10

        data = rnd.int_range(start, end, size=size)

        # Grouping elements on the basis of their remainder when dividing them by 10 and then
        # finding elements in each "bucket"
        out = Stream(data).collect(GroupingBy(mod_10, ToList()))

        out_target = defaultdict(list)

        for e in data:
            out_target[mod_10(e)].append(e)

        self.assertDictEqual(out, out_target)

    def test_4(self):
        rnd = random()

        start, end = 1, 100
        size = 1000

        def mod_10(x): return x % 10

        data = rnd.int_range(start, end, size=size)

        # Grouping elements on the basis of their remainder when dividing them by 10 and then
        # finding sum of elements in each bucket.
        out = Stream(data).collect(GroupingBy(mod_10, Summing()))

        out_target = defaultdict(int)

        for e in data:
            out_target[mod_10(e)] += e

        self.assertDictEqual(out, out_target)

    def test_4a(self):
        rnd = random()

        start, end = 1, 100
        size = 1000

        def mod_10(x): return x % 10

        data = rnd.int_range(start, end, size=size)

        # Grouping elements on the basis of their remainder when dividing them by 10 and then
        # finding sum of distinct elements in each bucket.
        out = Stream(data).collect(GroupingBy(mod_10, CollectAndThen(ToSet(), sum)))

        temp = defaultdict(set)

        for e in data:
            temp[mod_10(e)].add(e)

        out_target = {bkt: sum(es) for bkt, es in temp.items()}

        self.assertDictEqual(out, out_target)

    def test_5(self):
        rnd = random()

        start, end = 1, 100
        size = 1000

        def mod_10(x): return x % 10

        def square(x): return x ** 2

        data = rnd.int_range(start, end, size=size)

        # finding sum of squares of elements grouped by remainder when divided by 10.
        out = Stream(data).collect(GroupingBy(mod_10, Mapping(square, Summing())))

        out_target = defaultdict(int)

        for e in data:
            out_target[mod_10(e)] += square(e)

        self.assertDictEqual(out, out_target)

    def test_6(self):
        rnd = random()

        start, end = 1, 10000
        size = 1000

        def mod_100(x): return x % 100

        data = rnd.int_range(start, end, size=size)
        # finding distinct element count when grouped by their remainder when divided by 100.
        element_distinct_count = Stream(data).collect(GroupingBy(mod_100,
                                                                 CollectAndThen(ToSet(), len)))

        temp = defaultdict(set)

        for e in data:
            temp[mod_100(e)].add(e)

        out_target = {k: len(es) for k, es in temp.items()}

        self.assertDictEqual(element_distinct_count, out_target)

    def test_7(self):
        def mod_10(e): return e % 10

        # since their is no element in Stream, so "GroupingBy" will return empty dict.
        self.assertDictEqual(Stream(()).collect(GroupingBy(mod_10)), dict())

    def test_8(self):
        rnd = random()
        data_size = 1000
        countries = tuple('ABC')
        sex = ('M', 'F')

        class Person:
            def __init__(self, country, state, age, sex):
                self.country = country
                self.state = state
                self.age = age
                self.sex = sex

        ps = [Person(rnd.choice(countries),
                     rnd.randrange(1, 4),
                     rnd.randrange(0, 60),
                     rnd.choice(sex)) for _ in range(data_size)]
        # Counting Person on the basis of his/her country, then state
        # then on the basis of M/F.
        collector = GroupingBy(attrgetter('country'),
                               GroupingBy(attrgetter('state'),
                                          GroupingBy(attrgetter('sex'),
                                                     Counting())))

        def _filter(x: Person):
            return 20 <= x.age <= 50  # considering person of age between 20 and 50 (both inclusive)

        out = Stream(ps).filter(_filter).collect(collector)

        out_target = defaultdict(lambda: defaultdict(lambda: defaultdict(int)))

        for p in ps:
            if _filter(p):
                out_target[p.country][p.state][p.sex] += 1

        self.assertDictEqual(out, out_target)

    def test_9(self):
        data = range(10)

        def square(x): return x * x

        out = Stream(data).collect(ToMap(identity, square))
        out_target = {e: square(e) for e in data}

        self.assertDictEqual(out, out_target)

    @expectedFailure
    def test_10(self):
        data = [1, 3, 1]

        def square(x): return x * x

        # Value Error will be thrown, because number '1' is present multiple times.
        # and we have not provided any "merger_on_conflict".
        Stream(data).collect(ToMap(identity, square))

    def test_11(self):
        data = [1, 3, 1]

        def square(x): return x * x

        out = Stream(data).collect(ToMap(identity,
                                         square,
                                         merger_on_conflict=on_conflict_do_nothing))

        out_target = {1: 1, 3: 9}
        self.assertDictEqual(out, out_target)

    def test_12(self):
        class AdhaarCard:
            def __init__(self, idx, name):
                self.idx = idx
                self.name = name

            def get_id(self):
                return self.idx

            def get_name(self):
                return self.name

        ac = [AdhaarCard(idx, chr(idx)) for idx in range(65, 91)]

        out = Stream(ac).collect(ToMap(AdhaarCard.get_id, AdhaarCard.get_name))

        out_target = {idx: chr(idx) for idx in range(65, 91)}

        self.assertDictEqual(out, out_target)

    def test_13(self):
        data = tuple('ABC')

        self.assertEqual(Stream(data).collect(Joining()), 'ABC')

        self.assertEqual(Stream(data).collect(Joining(sep=',')), 'A,B,C')

        self.assertEqual(Stream(data).collect(Joining(sep=',', prefix='[')), '[A,B,C')

        self.assertEqual(Stream(data).collect(Joining(sep=',', prefix='[', suffix=']')), '[A,B,C]')

        self.assertEqual(Stream(data).collect(Joining(prefix='[', suffix=']')), '[ABC]')

        self.assertEqual(Stream(data).collect(Joining(suffix=']')), 'ABC]')

        self.assertEqual(Stream(data).collect(Joining(prefix='[')), '[ABC')

    def test_14(self):

        data = range(10)

        _sum = Stream(data).collect(Reduce(bi_func=op.add))

        self.assertTrue(_sum.present())
        self.assertEqual(_sum.get(), sum(data))

    def test_15(self):

        data = range(1, 10)

        _mult = Stream(data).collect(Reduce(bi_func=op.mul))

        self.assertTrue(_mult.present())
        self.assertEqual(_mult.get(), factorial(9))


if __name__ == '__main__':
    main()
