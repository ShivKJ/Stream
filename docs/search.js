window.pdocSearch = (function(){
/** elasticlunr - http://weixsong.github.io * Copyright (C) 2017 Oliver Nightingale * Copyright (C) 2017 Wei Song * MIT Licensed */!function(){function e(e){if(null===e||"object"!=typeof e)return e;var t=e.constructor();for(var n in e)e.hasOwnProperty(n)&&(t[n]=e[n]);return t}var t=function(e){var n=new t.Index;return n.pipeline.add(t.trimmer,t.stopWordFilter,t.stemmer),e&&e.call(n,n),n};t.version="0.9.5",lunr=t,t.utils={},t.utils.warn=function(e){return function(t){e.console&&console.warn&&console.warn(t)}}(this),t.utils.toString=function(e){return void 0===e||null===e?"":e.toString()},t.EventEmitter=function(){this.events={}},t.EventEmitter.prototype.addListener=function(){var e=Array.prototype.slice.call(arguments),t=e.pop(),n=e;if("function"!=typeof t)throw new TypeError("last argument must be a function");n.forEach(function(e){this.hasHandler(e)||(this.events[e]=[]),this.events[e].push(t)},this)},t.EventEmitter.prototype.removeListener=function(e,t){if(this.hasHandler(e)){var n=this.events[e].indexOf(t);-1!==n&&(this.events[e].splice(n,1),0==this.events[e].length&&delete this.events[e])}},t.EventEmitter.prototype.emit=function(e){if(this.hasHandler(e)){var t=Array.prototype.slice.call(arguments,1);this.events[e].forEach(function(e){e.apply(void 0,t)},this)}},t.EventEmitter.prototype.hasHandler=function(e){return e in this.events},t.tokenizer=function(e){if(!arguments.length||null===e||void 0===e)return[];if(Array.isArray(e)){var n=e.filter(function(e){return null===e||void 0===e?!1:!0});n=n.map(function(e){return t.utils.toString(e).toLowerCase()});var i=[];return n.forEach(function(e){var n=e.split(t.tokenizer.seperator);i=i.concat(n)},this),i}return e.toString().trim().toLowerCase().split(t.tokenizer.seperator)},t.tokenizer.defaultSeperator=/[\s\-]+/,t.tokenizer.seperator=t.tokenizer.defaultSeperator,t.tokenizer.setSeperator=function(e){null!==e&&void 0!==e&&"object"==typeof e&&(t.tokenizer.seperator=e)},t.tokenizer.resetSeperator=function(){t.tokenizer.seperator=t.tokenizer.defaultSeperator},t.tokenizer.getSeperator=function(){return t.tokenizer.seperator},t.Pipeline=function(){this._queue=[]},t.Pipeline.registeredFunctions={},t.Pipeline.registerFunction=function(e,n){n in t.Pipeline.registeredFunctions&&t.utils.warn("Overwriting existing registered function: "+n),e.label=n,t.Pipeline.registeredFunctions[n]=e},t.Pipeline.getRegisteredFunction=function(e){return e in t.Pipeline.registeredFunctions!=!0?null:t.Pipeline.registeredFunctions[e]},t.Pipeline.warnIfFunctionNotRegistered=function(e){var n=e.label&&e.label in this.registeredFunctions;n||t.utils.warn("Function is not registered with pipeline. This may cause problems when serialising the index.\n",e)},t.Pipeline.load=function(e){var n=new t.Pipeline;return e.forEach(function(e){var i=t.Pipeline.getRegisteredFunction(e);if(!i)throw new Error("Cannot load un-registered function: "+e);n.add(i)}),n},t.Pipeline.prototype.add=function(){var e=Array.prototype.slice.call(arguments);e.forEach(function(e){t.Pipeline.warnIfFunctionNotRegistered(e),this._queue.push(e)},this)},t.Pipeline.prototype.after=function(e,n){t.Pipeline.warnIfFunctionNotRegistered(n);var i=this._queue.indexOf(e);if(-1===i)throw new Error("Cannot find existingFn");this._queue.splice(i+1,0,n)},t.Pipeline.prototype.before=function(e,n){t.Pipeline.warnIfFunctionNotRegistered(n);var i=this._queue.indexOf(e);if(-1===i)throw new Error("Cannot find existingFn");this._queue.splice(i,0,n)},t.Pipeline.prototype.remove=function(e){var t=this._queue.indexOf(e);-1!==t&&this._queue.splice(t,1)},t.Pipeline.prototype.run=function(e){for(var t=[],n=e.length,i=this._queue.length,o=0;n>o;o++){for(var r=e[o],s=0;i>s&&(r=this._queue[s](r,o,e),void 0!==r&&null!==r);s++);void 0!==r&&null!==r&&t.push(r)}return t},t.Pipeline.prototype.reset=function(){this._queue=[]},t.Pipeline.prototype.get=function(){return this._queue},t.Pipeline.prototype.toJSON=function(){return this._queue.map(function(e){return t.Pipeline.warnIfFunctionNotRegistered(e),e.label})},t.Index=function(){this._fields=[],this._ref="id",this.pipeline=new t.Pipeline,this.documentStore=new t.DocumentStore,this.index={},this.eventEmitter=new t.EventEmitter,this._idfCache={},this.on("add","remove","update",function(){this._idfCache={}}.bind(this))},t.Index.prototype.on=function(){var e=Array.prototype.slice.call(arguments);return this.eventEmitter.addListener.apply(this.eventEmitter,e)},t.Index.prototype.off=function(e,t){return this.eventEmitter.removeListener(e,t)},t.Index.load=function(e){e.version!==t.version&&t.utils.warn("version mismatch: current "+t.version+" importing "+e.version);var n=new this;n._fields=e.fields,n._ref=e.ref,n.documentStore=t.DocumentStore.load(e.documentStore),n.pipeline=t.Pipeline.load(e.pipeline),n.index={};for(var i in e.index)n.index[i]=t.InvertedIndex.load(e.index[i]);return n},t.Index.prototype.addField=function(e){return this._fields.push(e),this.index[e]=new t.InvertedIndex,this},t.Index.prototype.setRef=function(e){return this._ref=e,this},t.Index.prototype.saveDocument=function(e){return this.documentStore=new t.DocumentStore(e),this},t.Index.prototype.addDoc=function(e,n){if(e){var n=void 0===n?!0:n,i=e[this._ref];this.documentStore.addDoc(i,e),this._fields.forEach(function(n){var o=this.pipeline.run(t.tokenizer(e[n]));this.documentStore.addFieldLength(i,n,o.length);var r={};o.forEach(function(e){e in r?r[e]+=1:r[e]=1},this);for(var s in r){var u=r[s];u=Math.sqrt(u),this.index[n].addToken(s,{ref:i,tf:u})}},this),n&&this.eventEmitter.emit("add",e,this)}},t.Index.prototype.removeDocByRef=function(e){if(e&&this.documentStore.isDocStored()!==!1&&this.documentStore.hasDoc(e)){var t=this.documentStore.getDoc(e);this.removeDoc(t,!1)}},t.Index.prototype.removeDoc=function(e,n){if(e){var n=void 0===n?!0:n,i=e[this._ref];this.documentStore.hasDoc(i)&&(this.documentStore.removeDoc(i),this._fields.forEach(function(n){var o=this.pipeline.run(t.tokenizer(e[n]));o.forEach(function(e){this.index[n].removeToken(e,i)},this)},this),n&&this.eventEmitter.emit("remove",e,this))}},t.Index.prototype.updateDoc=function(e,t){var t=void 0===t?!0:t;this.removeDocByRef(e[this._ref],!1),this.addDoc(e,!1),t&&this.eventEmitter.emit("update",e,this)},t.Index.prototype.idf=function(e,t){var n="@"+t+"/"+e;if(Object.prototype.hasOwnProperty.call(this._idfCache,n))return this._idfCache[n];var i=this.index[t].getDocFreq(e),o=1+Math.log(this.documentStore.length/(i+1));return this._idfCache[n]=o,o},t.Index.prototype.getFields=function(){return this._fields.slice()},t.Index.prototype.search=function(e,n){if(!e)return[];e="string"==typeof e?{any:e}:JSON.parse(JSON.stringify(e));var i=null;null!=n&&(i=JSON.stringify(n));for(var o=new t.Configuration(i,this.getFields()).get(),r={},s=Object.keys(e),u=0;u<s.length;u++){var a=s[u];r[a]=this.pipeline.run(t.tokenizer(e[a]))}var l={};for(var c in o){var d=r[c]||r.any;if(d){var f=this.fieldSearch(d,c,o),h=o[c].boost;for(var p in f)f[p]=f[p]*h;for(var p in f)p in l?l[p]+=f[p]:l[p]=f[p]}}var v,g=[];for(var p in l)v={ref:p,score:l[p]},this.documentStore.hasDoc(p)&&(v.doc=this.documentStore.getDoc(p)),g.push(v);return g.sort(function(e,t){return t.score-e.score}),g},t.Index.prototype.fieldSearch=function(e,t,n){var i=n[t].bool,o=n[t].expand,r=n[t].boost,s=null,u={};return 0!==r?(e.forEach(function(e){var n=[e];1==o&&(n=this.index[t].expandToken(e));var r={};n.forEach(function(n){var o=this.index[t].getDocs(n),a=this.idf(n,t);if(s&&"AND"==i){var l={};for(var c in s)c in o&&(l[c]=o[c]);o=l}n==e&&this.fieldSearchStats(u,n,o);for(var c in o){var d=this.index[t].getTermFrequency(n,c),f=this.documentStore.getFieldLength(c,t),h=1;0!=f&&(h=1/Math.sqrt(f));var p=1;n!=e&&(p=.15*(1-(n.length-e.length)/n.length));var v=d*a*h*p;c in r?r[c]+=v:r[c]=v}},this),s=this.mergeScores(s,r,i)},this),s=this.coordNorm(s,u,e.length)):void 0},t.Index.prototype.mergeScores=function(e,t,n){if(!e)return t;if("AND"==n){var i={};for(var o in t)o in e&&(i[o]=e[o]+t[o]);return i}for(var o in t)o in e?e[o]+=t[o]:e[o]=t[o];return e},t.Index.prototype.fieldSearchStats=function(e,t,n){for(var i in n)i in e?e[i].push(t):e[i]=[t]},t.Index.prototype.coordNorm=function(e,t,n){for(var i in e)if(i in t){var o=t[i].length;e[i]=e[i]*o/n}return e},t.Index.prototype.toJSON=function(){var e={};return this._fields.forEach(function(t){e[t]=this.index[t].toJSON()},this),{version:t.version,fields:this._fields,ref:this._ref,documentStore:this.documentStore.toJSON(),index:e,pipeline:this.pipeline.toJSON()}},t.Index.prototype.use=function(e){var t=Array.prototype.slice.call(arguments,1);t.unshift(this),e.apply(this,t)},t.DocumentStore=function(e){this._save=null===e||void 0===e?!0:e,this.docs={},this.docInfo={},this.length=0},t.DocumentStore.load=function(e){var t=new this;return t.length=e.length,t.docs=e.docs,t.docInfo=e.docInfo,t._save=e.save,t},t.DocumentStore.prototype.isDocStored=function(){return this._save},t.DocumentStore.prototype.addDoc=function(t,n){this.hasDoc(t)||this.length++,this.docs[t]=this._save===!0?e(n):null},t.DocumentStore.prototype.getDoc=function(e){return this.hasDoc(e)===!1?null:this.docs[e]},t.DocumentStore.prototype.hasDoc=function(e){return e in this.docs},t.DocumentStore.prototype.removeDoc=function(e){this.hasDoc(e)&&(delete this.docs[e],delete this.docInfo[e],this.length--)},t.DocumentStore.prototype.addFieldLength=function(e,t,n){null!==e&&void 0!==e&&0!=this.hasDoc(e)&&(this.docInfo[e]||(this.docInfo[e]={}),this.docInfo[e][t]=n)},t.DocumentStore.prototype.updateFieldLength=function(e,t,n){null!==e&&void 0!==e&&0!=this.hasDoc(e)&&this.addFieldLength(e,t,n)},t.DocumentStore.prototype.getFieldLength=function(e,t){return null===e||void 0===e?0:e in this.docs&&t in this.docInfo[e]?this.docInfo[e][t]:0},t.DocumentStore.prototype.toJSON=function(){return{docs:this.docs,docInfo:this.docInfo,length:this.length,save:this._save}},t.stemmer=function(){var e={ational:"ate",tional:"tion",enci:"ence",anci:"ance",izer:"ize",bli:"ble",alli:"al",entli:"ent",eli:"e",ousli:"ous",ization:"ize",ation:"ate",ator:"ate",alism:"al",iveness:"ive",fulness:"ful",ousness:"ous",aliti:"al",iviti:"ive",biliti:"ble",logi:"log"},t={icate:"ic",ative:"",alize:"al",iciti:"ic",ical:"ic",ful:"",ness:""},n="[^aeiou]",i="[aeiouy]",o=n+"[^aeiouy]*",r=i+"[aeiou]*",s="^("+o+")?"+r+o,u="^("+o+")?"+r+o+"("+r+")?$",a="^("+o+")?"+r+o+r+o,l="^("+o+")?"+i,c=new RegExp(s),d=new RegExp(a),f=new RegExp(u),h=new RegExp(l),p=/^(.+?)(ss|i)es$/,v=/^(.+?)([^s])s$/,g=/^(.+?)eed$/,m=/^(.+?)(ed|ing)$/,y=/.$/,S=/(at|bl|iz)$/,x=new RegExp("([^aeiouylsz])\\1$"),w=new RegExp("^"+o+i+"[^aeiouwxy]$"),I=/^(.+?[^aeiou])y$/,b=/^(.+?)(ational|tional|enci|anci|izer|bli|alli|entli|eli|ousli|ization|ation|ator|alism|iveness|fulness|ousness|aliti|iviti|biliti|logi)$/,E=/^(.+?)(icate|ative|alize|iciti|ical|ful|ness)$/,D=/^(.+?)(al|ance|ence|er|ic|able|ible|ant|ement|ment|ent|ou|ism|ate|iti|ous|ive|ize)$/,F=/^(.+?)(s|t)(ion)$/,_=/^(.+?)e$/,P=/ll$/,k=new RegExp("^"+o+i+"[^aeiouwxy]$"),z=function(n){var i,o,r,s,u,a,l;if(n.length<3)return n;if(r=n.substr(0,1),"y"==r&&(n=r.toUpperCase()+n.substr(1)),s=p,u=v,s.test(n)?n=n.replace(s,"$1$2"):u.test(n)&&(n=n.replace(u,"$1$2")),s=g,u=m,s.test(n)){var z=s.exec(n);s=c,s.test(z[1])&&(s=y,n=n.replace(s,""))}else if(u.test(n)){var z=u.exec(n);i=z[1],u=h,u.test(i)&&(n=i,u=S,a=x,l=w,u.test(n)?n+="e":a.test(n)?(s=y,n=n.replace(s,"")):l.test(n)&&(n+="e"))}if(s=I,s.test(n)){var z=s.exec(n);i=z[1],n=i+"i"}if(s=b,s.test(n)){var z=s.exec(n);i=z[1],o=z[2],s=c,s.test(i)&&(n=i+e[o])}if(s=E,s.test(n)){var z=s.exec(n);i=z[1],o=z[2],s=c,s.test(i)&&(n=i+t[o])}if(s=D,u=F,s.test(n)){var z=s.exec(n);i=z[1],s=d,s.test(i)&&(n=i)}else if(u.test(n)){var z=u.exec(n);i=z[1]+z[2],u=d,u.test(i)&&(n=i)}if(s=_,s.test(n)){var z=s.exec(n);i=z[1],s=d,u=f,a=k,(s.test(i)||u.test(i)&&!a.test(i))&&(n=i)}return s=P,u=d,s.test(n)&&u.test(n)&&(s=y,n=n.replace(s,"")),"y"==r&&(n=r.toLowerCase()+n.substr(1)),n};return z}(),t.Pipeline.registerFunction(t.stemmer,"stemmer"),t.stopWordFilter=function(e){return e&&t.stopWordFilter.stopWords[e]!==!0?e:void 0},t.clearStopWords=function(){t.stopWordFilter.stopWords={}},t.addStopWords=function(e){null!=e&&Array.isArray(e)!==!1&&e.forEach(function(e){t.stopWordFilter.stopWords[e]=!0},this)},t.resetStopWords=function(){t.stopWordFilter.stopWords=t.defaultStopWords},t.defaultStopWords={"":!0,a:!0,able:!0,about:!0,across:!0,after:!0,all:!0,almost:!0,also:!0,am:!0,among:!0,an:!0,and:!0,any:!0,are:!0,as:!0,at:!0,be:!0,because:!0,been:!0,but:!0,by:!0,can:!0,cannot:!0,could:!0,dear:!0,did:!0,"do":!0,does:!0,either:!0,"else":!0,ever:!0,every:!0,"for":!0,from:!0,get:!0,got:!0,had:!0,has:!0,have:!0,he:!0,her:!0,hers:!0,him:!0,his:!0,how:!0,however:!0,i:!0,"if":!0,"in":!0,into:!0,is:!0,it:!0,its:!0,just:!0,least:!0,let:!0,like:!0,likely:!0,may:!0,me:!0,might:!0,most:!0,must:!0,my:!0,neither:!0,no:!0,nor:!0,not:!0,of:!0,off:!0,often:!0,on:!0,only:!0,or:!0,other:!0,our:!0,own:!0,rather:!0,said:!0,say:!0,says:!0,she:!0,should:!0,since:!0,so:!0,some:!0,than:!0,that:!0,the:!0,their:!0,them:!0,then:!0,there:!0,these:!0,they:!0,"this":!0,tis:!0,to:!0,too:!0,twas:!0,us:!0,wants:!0,was:!0,we:!0,were:!0,what:!0,when:!0,where:!0,which:!0,"while":!0,who:!0,whom:!0,why:!0,will:!0,"with":!0,would:!0,yet:!0,you:!0,your:!0},t.stopWordFilter.stopWords=t.defaultStopWords,t.Pipeline.registerFunction(t.stopWordFilter,"stopWordFilter"),t.trimmer=function(e){if(null===e||void 0===e)throw new Error("token should not be undefined");return e.replace(/^\W+/,"").replace(/\W+$/,"")},t.Pipeline.registerFunction(t.trimmer,"trimmer"),t.InvertedIndex=function(){this.root={docs:{},df:0}},t.InvertedIndex.load=function(e){var t=new this;return t.root=e.root,t},t.InvertedIndex.prototype.addToken=function(e,t,n){for(var n=n||this.root,i=0;i<=e.length-1;){var o=e[i];o in n||(n[o]={docs:{},df:0}),i+=1,n=n[o]}var r=t.ref;n.docs[r]?n.docs[r]={tf:t.tf}:(n.docs[r]={tf:t.tf},n.df+=1)},t.InvertedIndex.prototype.hasToken=function(e){if(!e)return!1;for(var t=this.root,n=0;n<e.length;n++){if(!t[e[n]])return!1;t=t[e[n]]}return!0},t.InvertedIndex.prototype.getNode=function(e){if(!e)return null;for(var t=this.root,n=0;n<e.length;n++){if(!t[e[n]])return null;t=t[e[n]]}return t},t.InvertedIndex.prototype.getDocs=function(e){var t=this.getNode(e);return null==t?{}:t.docs},t.InvertedIndex.prototype.getTermFrequency=function(e,t){var n=this.getNode(e);return null==n?0:t in n.docs?n.docs[t].tf:0},t.InvertedIndex.prototype.getDocFreq=function(e){var t=this.getNode(e);return null==t?0:t.df},t.InvertedIndex.prototype.removeToken=function(e,t){if(e){var n=this.getNode(e);null!=n&&t in n.docs&&(delete n.docs[t],n.df-=1)}},t.InvertedIndex.prototype.expandToken=function(e,t,n){if(null==e||""==e)return[];var t=t||[];if(void 0==n&&(n=this.getNode(e),null==n))return t;n.df>0&&t.push(e);for(var i in n)"docs"!==i&&"df"!==i&&this.expandToken(e+i,t,n[i]);return t},t.InvertedIndex.prototype.toJSON=function(){return{root:this.root}},t.Configuration=function(e,n){var e=e||"";if(void 0==n||null==n)throw new Error("fields should not be null");this.config={};var i;try{i=JSON.parse(e),this.buildUserConfig(i,n)}catch(o){t.utils.warn("user configuration parse failed, will use default configuration"),this.buildDefaultConfig(n)}},t.Configuration.prototype.buildDefaultConfig=function(e){this.reset(),e.forEach(function(e){this.config[e]={boost:1,bool:"OR",expand:!1}},this)},t.Configuration.prototype.buildUserConfig=function(e,n){var i="OR",o=!1;if(this.reset(),"bool"in e&&(i=e.bool||i),"expand"in e&&(o=e.expand||o),"fields"in e)for(var r in e.fields)if(n.indexOf(r)>-1){var s=e.fields[r],u=o;void 0!=s.expand&&(u=s.expand),this.config[r]={boost:s.boost||0===s.boost?s.boost:1,bool:s.bool||i,expand:u}}else t.utils.warn("field name in user configuration not found in index instance fields");else this.addAllFields2UserConfig(i,o,n)},t.Configuration.prototype.addAllFields2UserConfig=function(e,t,n){n.forEach(function(n){this.config[n]={boost:1,bool:e,expand:t}},this)},t.Configuration.prototype.get=function(){return this.config},t.Configuration.prototype.reset=function(){this.config={}},lunr.SortedSet=function(){this.length=0,this.elements=[]},lunr.SortedSet.load=function(e){var t=new this;return t.elements=e,t.length=e.length,t},lunr.SortedSet.prototype.add=function(){var e,t;for(e=0;e<arguments.length;e++)t=arguments[e],~this.indexOf(t)||this.elements.splice(this.locationFor(t),0,t);this.length=this.elements.length},lunr.SortedSet.prototype.toArray=function(){return this.elements.slice()},lunr.SortedSet.prototype.map=function(e,t){return this.elements.map(e,t)},lunr.SortedSet.prototype.forEach=function(e,t){return this.elements.forEach(e,t)},lunr.SortedSet.prototype.indexOf=function(e){for(var t=0,n=this.elements.length,i=n-t,o=t+Math.floor(i/2),r=this.elements[o];i>1;){if(r===e)return o;e>r&&(t=o),r>e&&(n=o),i=n-t,o=t+Math.floor(i/2),r=this.elements[o]}return r===e?o:-1},lunr.SortedSet.prototype.locationFor=function(e){for(var t=0,n=this.elements.length,i=n-t,o=t+Math.floor(i/2),r=this.elements[o];i>1;)e>r&&(t=o),r>e&&(n=o),i=n-t,o=t+Math.floor(i/2),r=this.elements[o];return r>e?o:e>r?o+1:void 0},lunr.SortedSet.prototype.intersect=function(e){for(var t=new lunr.SortedSet,n=0,i=0,o=this.length,r=e.length,s=this.elements,u=e.elements;;){if(n>o-1||i>r-1)break;s[n]!==u[i]?s[n]<u[i]?n++:s[n]>u[i]&&i++:(t.add(s[n]),n++,i++)}return t},lunr.SortedSet.prototype.clone=function(){var e=new lunr.SortedSet;return e.elements=this.toArray(),e.length=e.elements.length,e},lunr.SortedSet.prototype.union=function(e){var t,n,i;this.length>=e.length?(t=this,n=e):(t=e,n=this),i=t.clone();for(var o=0,r=n.toArray();o<r.length;o++)i.add(r[o]);return i},lunr.SortedSet.prototype.toJSON=function(){return this.toArray()},function(e,t){"function"==typeof define&&define.amd?define(t):"object"==typeof exports?module.exports=t():e.elasticlunr=t()}(this,function(){return t})}();
    /** pdoc search index */const docs = [{"fullname": "streamAPI", "modulename": "streamAPI", "kind": "module", "doc": "<p></p>\n"}, {"fullname": "streamAPI.stream", "modulename": "streamAPI.stream", "kind": "module", "doc": "<p></p>\n"}, {"fullname": "streamAPI.stream.TO", "modulename": "streamAPI.stream.TO", "kind": "module", "doc": "<p></p>\n"}, {"fullname": "streamAPI.stream.TO.TerminalOperations", "modulename": "streamAPI.stream.TO.TerminalOperations", "kind": "module", "doc": "<p>author: Shiv\nemail: shivkj001@gmail.com</p>\n"}, {"fullname": "streamAPI.stream.TO.TerminalOperations.Averaging", "modulename": "streamAPI.stream.TO.TerminalOperations", "qualname": "Averaging", "kind": "class", "doc": "<p>Finds average of elements.\nStream(range(5)).collect(Averaging()) -> 2.0</p>\n", "bases": "Summing, Counting"}, {"fullname": "streamAPI.stream.TO.TerminalOperations.Averaging.supply", "modulename": "streamAPI.stream.TO.TerminalOperations", "qualname": "Averaging.supply", "kind": "function", "doc": "<p>supplies a new Collector.</p>\n\n<h6 id=\"returns\">Returns</h6>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"bp\">self</span></span><span class=\"return-annotation\">) -> <span class=\"n\">streamAPI</span><span class=\"o\">.</span><span class=\"n\">stream</span><span class=\"o\">.</span><span class=\"n\">TO</span><span class=\"o\">.</span><span class=\"n\">TerminalOperations</span><span class=\"o\">.</span><span class=\"n\">Collector</span>:</span></span>", "funcdef": "def"}, {"fullname": "streamAPI.stream.TO.TerminalOperations.Averaging.consume", "modulename": "streamAPI.stream.TO.TerminalOperations", "qualname": "Averaging.consume", "kind": "function", "doc": "<p>Defines how to process a data \"e\".</p>\n\n<h6 id=\"parameters\">Parameters</h6>\n\n<ul>\n<li><strong>e</strong>: </li>\n</ul>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"bp\">self</span>, </span><span class=\"param\"><span class=\"n\">e</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "streamAPI.stream.TO.TerminalOperations.Averaging.finish", "modulename": "streamAPI.stream.TO.TerminalOperations", "qualname": "Averaging.finish", "kind": "function", "doc": "<p>defines what to return with \"consumed\" elements.</p>\n\n<h6 id=\"returns\">Returns</h6>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"bp\">self</span></span><span class=\"return-annotation\">) -> <span class=\"nb\">float</span>:</span></span>", "funcdef": "def"}, {"fullname": "streamAPI.stream.TO.TerminalOperations.CollectAndThen", "modulename": "streamAPI.stream.TO.TerminalOperations", "qualname": "CollectAndThen", "kind": "class", "doc": "<p>Collects elements using \"downstream\" and then applies the \"then\" function.</p>\n\n<p>Stream([1,4,2,6,1,5,6]).collect(CollectAndThen(ToSet(),sum)) -> 18\nStream([1,4,2,6,1,5,6]).collect(CollectAndThen(ToList(),sum)) -> 25</p>\n", "bases": "Collector"}, {"fullname": "streamAPI.stream.TO.TerminalOperations.CollectAndThen.__init__", "modulename": "streamAPI.stream.TO.TerminalOperations", "qualname": "CollectAndThen.__init__", "kind": "function", "doc": "<p></p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">downstream</span><span class=\"p\">:</span> <span class=\"n\">streamAPI</span><span class=\"o\">.</span><span class=\"n\">stream</span><span class=\"o\">.</span><span class=\"n\">TO</span><span class=\"o\">.</span><span class=\"n\">TerminalOperations</span><span class=\"o\">.</span><span class=\"n\">Collector</span>, </span><span class=\"param\"><span class=\"n\">then</span></span>)</span>"}, {"fullname": "streamAPI.stream.TO.TerminalOperations.CollectAndThen.supply", "modulename": "streamAPI.stream.TO.TerminalOperations", "qualname": "CollectAndThen.supply", "kind": "function", "doc": "<p>supplies a new Collector.</p>\n\n<h6 id=\"returns\">Returns</h6>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"bp\">self</span></span><span class=\"return-annotation\">) -> <span class=\"n\">streamAPI</span><span class=\"o\">.</span><span class=\"n\">stream</span><span class=\"o\">.</span><span class=\"n\">TO</span><span class=\"o\">.</span><span class=\"n\">TerminalOperations</span><span class=\"o\">.</span><span class=\"n\">Collector</span>:</span></span>", "funcdef": "def"}, {"fullname": "streamAPI.stream.TO.TerminalOperations.CollectAndThen.consume", "modulename": "streamAPI.stream.TO.TerminalOperations", "qualname": "CollectAndThen.consume", "kind": "function", "doc": "<p>Defines how to process a data \"e\".</p>\n\n<h6 id=\"parameters\">Parameters</h6>\n\n<ul>\n<li><strong>e</strong>: </li>\n</ul>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"bp\">self</span>, </span><span class=\"param\"><span class=\"n\">e</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "streamAPI.stream.TO.TerminalOperations.CollectAndThen.finish", "modulename": "streamAPI.stream.TO.TerminalOperations", "qualname": "CollectAndThen.finish", "kind": "function", "doc": "<p>defines what to return with \"consumed\" elements.</p>\n\n<h6 id=\"returns\">Returns</h6>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"bp\">self</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "streamAPI.stream.TO.TerminalOperations.Collector", "modulename": "streamAPI.stream.TO.TerminalOperations", "qualname": "Collector", "kind": "class", "doc": "<p>Object of this class will be used in Stream.collect method.</p>\n", "bases": "abc.ABC"}, {"fullname": "streamAPI.stream.TO.TerminalOperations.Collector.supply", "modulename": "streamAPI.stream.TO.TerminalOperations", "qualname": "Collector.supply", "kind": "function", "doc": "<p>supplies a new Collector.</p>\n\n<h6 id=\"returns\">Returns</h6>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"bp\">self</span></span><span class=\"return-annotation\">) -> <span class=\"n\">streamAPI</span><span class=\"o\">.</span><span class=\"n\">stream</span><span class=\"o\">.</span><span class=\"n\">TO</span><span class=\"o\">.</span><span class=\"n\">TerminalOperations</span><span class=\"o\">.</span><span class=\"n\">Collector</span>:</span></span>", "funcdef": "def"}, {"fullname": "streamAPI.stream.TO.TerminalOperations.Collector.consume", "modulename": "streamAPI.stream.TO.TerminalOperations", "qualname": "Collector.consume", "kind": "function", "doc": "<p>Defines how to process a data \"e\".</p>\n\n<h6 id=\"parameters\">Parameters</h6>\n\n<ul>\n<li><strong>e</strong>: </li>\n</ul>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"bp\">self</span>, </span><span class=\"param\"><span class=\"n\">e</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "streamAPI.stream.TO.TerminalOperations.Collector.finish", "modulename": "streamAPI.stream.TO.TerminalOperations", "qualname": "Collector.finish", "kind": "function", "doc": "<p>defines what to return with \"consumed\" elements.</p>\n\n<h6 id=\"returns\">Returns</h6>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"bp\">self</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "streamAPI.stream.TO.TerminalOperations.Counting", "modulename": "streamAPI.stream.TO.TerminalOperations", "qualname": "Counting", "kind": "class", "doc": "<p>Counts number of elements in Stream.</p>\n\n<p>Stream(range(5)).collect(Counting()) -> 5</p>\n", "bases": "Collector"}, {"fullname": "streamAPI.stream.TO.TerminalOperations.Counting.supply", "modulename": "streamAPI.stream.TO.TerminalOperations", "qualname": "Counting.supply", "kind": "function", "doc": "<p>supplies a new Collector.</p>\n\n<h6 id=\"returns\">Returns</h6>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"bp\">self</span></span><span class=\"return-annotation\">) -> <span class=\"n\">streamAPI</span><span class=\"o\">.</span><span class=\"n\">stream</span><span class=\"o\">.</span><span class=\"n\">TO</span><span class=\"o\">.</span><span class=\"n\">TerminalOperations</span><span class=\"o\">.</span><span class=\"n\">Collector</span>:</span></span>", "funcdef": "def"}, {"fullname": "streamAPI.stream.TO.TerminalOperations.Counting.consume", "modulename": "streamAPI.stream.TO.TerminalOperations", "qualname": "Counting.consume", "kind": "function", "doc": "<p>Defines how to process a data \"e\".</p>\n\n<h6 id=\"parameters\">Parameters</h6>\n\n<ul>\n<li><strong>e</strong>: </li>\n</ul>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"bp\">self</span>, </span><span class=\"param\"><span class=\"n\">e</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "streamAPI.stream.TO.TerminalOperations.Counting.finish", "modulename": "streamAPI.stream.TO.TerminalOperations", "qualname": "Counting.finish", "kind": "function", "doc": "<p>defines what to return with \"consumed\" elements.</p>\n\n<h6 id=\"returns\">Returns</h6>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"bp\">self</span></span><span class=\"return-annotation\">) -> <span class=\"nb\">int</span>:</span></span>", "funcdef": "def"}, {"fullname": "streamAPI.stream.TO.TerminalOperations.DataHolder", "modulename": "streamAPI.stream.TO.TerminalOperations", "qualname": "DataHolder", "kind": "class", "doc": "<p>This class will be used to hold stream data into\ncontainer such as 'list','set','deque' etc.</p>\n", "bases": "Collector"}, {"fullname": "streamAPI.stream.TO.TerminalOperations.DataHolder.supply", "modulename": "streamAPI.stream.TO.TerminalOperations", "qualname": "DataHolder.supply", "kind": "function", "doc": "<p>supplies a new Collector.</p>\n\n<h6 id=\"returns\">Returns</h6>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"bp\">self</span></span><span class=\"return-annotation\">) -> <span class=\"n\">streamAPI</span><span class=\"o\">.</span><span class=\"n\">stream</span><span class=\"o\">.</span><span class=\"n\">TO</span><span class=\"o\">.</span><span class=\"n\">TerminalOperations</span><span class=\"o\">.</span><span class=\"n\">Collector</span>:</span></span>", "funcdef": "def"}, {"fullname": "streamAPI.stream.TO.TerminalOperations.DataHolder.consume", "modulename": "streamAPI.stream.TO.TerminalOperations", "qualname": "DataHolder.consume", "kind": "function", "doc": "<p>Defines how to process a data \"e\".</p>\n\n<h6 id=\"parameters\">Parameters</h6>\n\n<ul>\n<li><strong>e</strong>: </li>\n</ul>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"bp\">self</span>, </span><span class=\"param\"><span class=\"n\">e</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "streamAPI.stream.TO.TerminalOperations.DataHolder.finish", "modulename": "streamAPI.stream.TO.TerminalOperations", "qualname": "DataHolder.finish", "kind": "function", "doc": "<p>defines what to return with \"consumed\" elements.</p>\n\n<h6 id=\"returns\">Returns</h6>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"bp\">self</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "streamAPI.stream.TO.TerminalOperations.GroupingBy", "modulename": "streamAPI.stream.TO.TerminalOperations", "qualname": "GroupingBy", "kind": "class", "doc": "<p>Groups stream elements.</p>\n\n<p>Stream(['AB','BD','AC','DE','BD','BW','AB']).collect(GroupingBy(lambda x:x[0],\n                                                                GroupingBy(lambda x:x[1],\n                                                                            Counting())))\n-> {'A': {'B': 2, 'C': 1}, 'B': {'D': 2, 'W': 1}, 'D': {'E': 1}}</p>\n", "bases": "Collector"}, {"fullname": "streamAPI.stream.TO.TerminalOperations.GroupingBy.__init__", "modulename": "streamAPI.stream.TO.TerminalOperations", "qualname": "GroupingBy.__init__", "kind": "function", "doc": "<p></p>\n", "signature": "<span class=\"signature pdoc-code multiline\">(<span class=\"param\">\t<span class=\"n\">group_by</span><span class=\"p\">:</span> <span class=\"n\">Callable</span><span class=\"p\">[[</span><span class=\"o\">~</span><span class=\"n\">X</span><span class=\"p\">],</span> <span class=\"o\">~</span><span class=\"n\">Y</span><span class=\"p\">]</span>,</span><span class=\"param\">\t<span class=\"n\">downstream</span><span class=\"p\">:</span> <span class=\"n\">streamAPI</span><span class=\"o\">.</span><span class=\"n\">stream</span><span class=\"o\">.</span><span class=\"n\">TO</span><span class=\"o\">.</span><span class=\"n\">TerminalOperations</span><span class=\"o\">.</span><span class=\"n\">Collector</span> <span class=\"o\">=</span> <span class=\"kc\">None</span></span>)</span>"}, {"fullname": "streamAPI.stream.TO.TerminalOperations.GroupingBy.supply", "modulename": "streamAPI.stream.TO.TerminalOperations", "qualname": "GroupingBy.supply", "kind": "function", "doc": "<p>supplies a new Collector.</p>\n\n<h6 id=\"returns\">Returns</h6>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"bp\">self</span></span><span class=\"return-annotation\">) -> <span class=\"n\">streamAPI</span><span class=\"o\">.</span><span class=\"n\">stream</span><span class=\"o\">.</span><span class=\"n\">TO</span><span class=\"o\">.</span><span class=\"n\">TerminalOperations</span><span class=\"o\">.</span><span class=\"n\">Collector</span>:</span></span>", "funcdef": "def"}, {"fullname": "streamAPI.stream.TO.TerminalOperations.GroupingBy.consume", "modulename": "streamAPI.stream.TO.TerminalOperations", "qualname": "GroupingBy.consume", "kind": "function", "doc": "<p>Defines how to process a data \"e\".</p>\n\n<h6 id=\"parameters\">Parameters</h6>\n\n<ul>\n<li><strong>e</strong>: </li>\n</ul>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"bp\">self</span>, </span><span class=\"param\"><span class=\"n\">e</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "streamAPI.stream.TO.TerminalOperations.GroupingBy.finish", "modulename": "streamAPI.stream.TO.TerminalOperations", "qualname": "GroupingBy.finish", "kind": "function", "doc": "<p>defines what to return with \"consumed\" elements.</p>\n\n<h6 id=\"returns\">Returns</h6>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"bp\">self</span></span><span class=\"return-annotation\">) -> <span class=\"nb\">dict</span>:</span></span>", "funcdef": "def"}, {"fullname": "streamAPI.stream.TO.TerminalOperations.Joining", "modulename": "streamAPI.stream.TO.TerminalOperations", "qualname": "Joining", "kind": "class", "doc": "<p>Joins string elements.</p>\n\n<p>Stream(['A','B','C']).collect(Joining(',','&lt;','>')) -> '<A,B,C>'</p>\n", "bases": "ToLinkedList"}, {"fullname": "streamAPI.stream.TO.TerminalOperations.Joining.__init__", "modulename": "streamAPI.stream.TO.TerminalOperations", "qualname": "Joining.__init__", "kind": "function", "doc": "<p></p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">sep</span><span class=\"p\">:</span> <span class=\"nb\">str</span> <span class=\"o\">=</span> <span class=\"s1\">&#39;&#39;</span>, </span><span class=\"param\"><span class=\"n\">prefix</span><span class=\"p\">:</span> <span class=\"nb\">str</span> <span class=\"o\">=</span> <span class=\"s1\">&#39;&#39;</span>, </span><span class=\"param\"><span class=\"n\">suffix</span><span class=\"p\">:</span> <span class=\"nb\">str</span> <span class=\"o\">=</span> <span class=\"s1\">&#39;&#39;</span></span>)</span>"}, {"fullname": "streamAPI.stream.TO.TerminalOperations.Joining.supply", "modulename": "streamAPI.stream.TO.TerminalOperations", "qualname": "Joining.supply", "kind": "function", "doc": "<p>supplies a new Collector.</p>\n\n<h6 id=\"returns\">Returns</h6>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"bp\">self</span></span><span class=\"return-annotation\">) -> <span class=\"n\">streamAPI</span><span class=\"o\">.</span><span class=\"n\">stream</span><span class=\"o\">.</span><span class=\"n\">TO</span><span class=\"o\">.</span><span class=\"n\">TerminalOperations</span><span class=\"o\">.</span><span class=\"n\">Collector</span>:</span></span>", "funcdef": "def"}, {"fullname": "streamAPI.stream.TO.TerminalOperations.Joining.finish", "modulename": "streamAPI.stream.TO.TerminalOperations", "qualname": "Joining.finish", "kind": "function", "doc": "<p>defines what to return with \"consumed\" elements.</p>\n\n<h6 id=\"returns\">Returns</h6>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"bp\">self</span></span><span class=\"return-annotation\">) -> <span class=\"nb\">str</span>:</span></span>", "funcdef": "def"}, {"fullname": "streamAPI.stream.TO.TerminalOperations.Mapping", "modulename": "streamAPI.stream.TO.TerminalOperations", "qualname": "Mapping", "kind": "class", "doc": "<p>Maps elements using \"func\" function first, then collects transformed\nelements according to \"downstream\".</p>\n\n<p>Stream(range(5)).collect(Mapping(lambda x:x**2,Summing()))\n-> 30 # sum of squares</p>\n", "bases": "Collector"}, {"fullname": "streamAPI.stream.TO.TerminalOperations.Mapping.__init__", "modulename": "streamAPI.stream.TO.TerminalOperations", "qualname": "Mapping.__init__", "kind": "function", "doc": "<p></p>\n", "signature": "<span class=\"signature pdoc-code multiline\">(<span class=\"param\">\t<span class=\"n\">func</span><span class=\"p\">:</span> <span class=\"n\">Callable</span><span class=\"p\">[[</span><span class=\"o\">~</span><span class=\"n\">X</span><span class=\"p\">],</span> <span class=\"o\">~</span><span class=\"n\">Y</span><span class=\"p\">]</span>,</span><span class=\"param\">\t<span class=\"n\">downstream</span><span class=\"p\">:</span> <span class=\"n\">streamAPI</span><span class=\"o\">.</span><span class=\"n\">stream</span><span class=\"o\">.</span><span class=\"n\">TO</span><span class=\"o\">.</span><span class=\"n\">TerminalOperations</span><span class=\"o\">.</span><span class=\"n\">Collector</span> <span class=\"o\">=</span> <span class=\"kc\">None</span></span>)</span>"}, {"fullname": "streamAPI.stream.TO.TerminalOperations.Mapping.supply", "modulename": "streamAPI.stream.TO.TerminalOperations", "qualname": "Mapping.supply", "kind": "function", "doc": "<p>supplies a new Collector.</p>\n\n<h6 id=\"returns\">Returns</h6>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"bp\">self</span></span><span class=\"return-annotation\">) -> <span class=\"n\">streamAPI</span><span class=\"o\">.</span><span class=\"n\">stream</span><span class=\"o\">.</span><span class=\"n\">TO</span><span class=\"o\">.</span><span class=\"n\">TerminalOperations</span><span class=\"o\">.</span><span class=\"n\">Collector</span>:</span></span>", "funcdef": "def"}, {"fullname": "streamAPI.stream.TO.TerminalOperations.Mapping.consume", "modulename": "streamAPI.stream.TO.TerminalOperations", "qualname": "Mapping.consume", "kind": "function", "doc": "<p>Defines how to process a data \"e\".</p>\n\n<h6 id=\"parameters\">Parameters</h6>\n\n<ul>\n<li><strong>e</strong>: </li>\n</ul>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"bp\">self</span>, </span><span class=\"param\"><span class=\"n\">e</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "streamAPI.stream.TO.TerminalOperations.Mapping.finish", "modulename": "streamAPI.stream.TO.TerminalOperations", "qualname": "Mapping.finish", "kind": "function", "doc": "<p>defines what to return with \"consumed\" elements.</p>\n\n<h6 id=\"returns\">Returns</h6>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"bp\">self</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "streamAPI.stream.TO.TerminalOperations.MaxBy", "modulename": "streamAPI.stream.TO.TerminalOperations", "qualname": "MaxBy", "kind": "class", "doc": "<p>Finds max element using comparator \"comp\"\nStream([1,4,2,6,1,5,6]).collect(MaxBy()) -> Optional[6]</p>\n", "bases": "Collector"}, {"fullname": "streamAPI.stream.TO.TerminalOperations.MaxBy.__init__", "modulename": "streamAPI.stream.TO.TerminalOperations", "qualname": "MaxBy.__init__", "kind": "function", "doc": "<p></p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">comp</span><span class=\"p\">:</span> <span class=\"n\">Callable</span><span class=\"p\">[[</span><span class=\"o\">~</span><span class=\"n\">X</span><span class=\"p\">,</span> <span class=\"o\">~</span><span class=\"n\">X</span><span class=\"p\">],</span> <span class=\"nb\">int</span><span class=\"p\">]</span> <span class=\"o\">=</span> <span class=\"o\">&lt;</span><span class=\"n\">function</span> <span class=\"n\">default_comp</span><span class=\"o\">&gt;</span></span>)</span>"}, {"fullname": "streamAPI.stream.TO.TerminalOperations.MaxBy.supply", "modulename": "streamAPI.stream.TO.TerminalOperations", "qualname": "MaxBy.supply", "kind": "function", "doc": "<p>supplies a new Collector.</p>\n\n<h6 id=\"returns\">Returns</h6>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"bp\">self</span></span><span class=\"return-annotation\">) -> <span class=\"n\">streamAPI</span><span class=\"o\">.</span><span class=\"n\">stream</span><span class=\"o\">.</span><span class=\"n\">TO</span><span class=\"o\">.</span><span class=\"n\">TerminalOperations</span><span class=\"o\">.</span><span class=\"n\">Collector</span>:</span></span>", "funcdef": "def"}, {"fullname": "streamAPI.stream.TO.TerminalOperations.MaxBy.consume", "modulename": "streamAPI.stream.TO.TerminalOperations", "qualname": "MaxBy.consume", "kind": "function", "doc": "<p>Defines how to process a data \"e\".</p>\n\n<h6 id=\"parameters\">Parameters</h6>\n\n<ul>\n<li><strong>e</strong>: </li>\n</ul>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"bp\">self</span>, </span><span class=\"param\"><span class=\"n\">e</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "streamAPI.stream.TO.TerminalOperations.MaxBy.finish", "modulename": "streamAPI.stream.TO.TerminalOperations", "qualname": "MaxBy.finish", "kind": "function", "doc": "<p>defines what to return with \"consumed\" elements.</p>\n\n<h6 id=\"returns\">Returns</h6>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"bp\">self</span></span><span class=\"return-annotation\">) -> <span class=\"n\">streamAPI</span><span class=\"o\">.</span><span class=\"n\">stream</span><span class=\"o\">.</span><span class=\"n\">optional</span><span class=\"o\">.</span><span class=\"n\">Optional</span>:</span></span>", "funcdef": "def"}, {"fullname": "streamAPI.stream.TO.TerminalOperations.MinBy", "modulename": "streamAPI.stream.TO.TerminalOperations", "qualname": "MinBy", "kind": "class", "doc": "<p>Finds min element using comparator \"comp\"\nStream([1,4,2,6,1,5,6]).collect(MinBy()) -> Optional[1]</p>\n", "bases": "Collector"}, {"fullname": "streamAPI.stream.TO.TerminalOperations.MinBy.__init__", "modulename": "streamAPI.stream.TO.TerminalOperations", "qualname": "MinBy.__init__", "kind": "function", "doc": "<p></p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">comp</span><span class=\"p\">:</span> <span class=\"n\">Callable</span><span class=\"p\">[[</span><span class=\"o\">~</span><span class=\"n\">X</span><span class=\"p\">,</span> <span class=\"o\">~</span><span class=\"n\">X</span><span class=\"p\">],</span> <span class=\"nb\">int</span><span class=\"p\">]</span> <span class=\"o\">=</span> <span class=\"o\">&lt;</span><span class=\"n\">function</span> <span class=\"n\">default_comp</span><span class=\"o\">&gt;</span></span>)</span>"}, {"fullname": "streamAPI.stream.TO.TerminalOperations.MinBy.supply", "modulename": "streamAPI.stream.TO.TerminalOperations", "qualname": "MinBy.supply", "kind": "function", "doc": "<p>supplies a new Collector.</p>\n\n<h6 id=\"returns\">Returns</h6>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"bp\">self</span></span><span class=\"return-annotation\">) -> <span class=\"n\">streamAPI</span><span class=\"o\">.</span><span class=\"n\">stream</span><span class=\"o\">.</span><span class=\"n\">TO</span><span class=\"o\">.</span><span class=\"n\">TerminalOperations</span><span class=\"o\">.</span><span class=\"n\">Collector</span>:</span></span>", "funcdef": "def"}, {"fullname": "streamAPI.stream.TO.TerminalOperations.MinBy.consume", "modulename": "streamAPI.stream.TO.TerminalOperations", "qualname": "MinBy.consume", "kind": "function", "doc": "<p>Defines how to process a data \"e\".</p>\n\n<h6 id=\"parameters\">Parameters</h6>\n\n<ul>\n<li><strong>e</strong>: </li>\n</ul>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"bp\">self</span>, </span><span class=\"param\"><span class=\"n\">e</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "streamAPI.stream.TO.TerminalOperations.MinBy.finish", "modulename": "streamAPI.stream.TO.TerminalOperations", "qualname": "MinBy.finish", "kind": "function", "doc": "<p>defines what to return with \"consumed\" elements.</p>\n\n<h6 id=\"returns\">Returns</h6>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"bp\">self</span></span><span class=\"return-annotation\">) -> <span class=\"n\">streamAPI</span><span class=\"o\">.</span><span class=\"n\">stream</span><span class=\"o\">.</span><span class=\"n\">optional</span><span class=\"o\">.</span><span class=\"n\">Optional</span>:</span></span>", "funcdef": "def"}, {"fullname": "streamAPI.stream.TO.TerminalOperations.Reduce", "modulename": "streamAPI.stream.TO.TerminalOperations", "qualname": "Reduce", "kind": "class", "doc": "<p>Reduces stream data.</p>\n\n<p>import operator as op\nStream(range(1,5)).collect(Reduce(bi_func=op.mul)) -> Optional[24]</p>\n", "bases": "Collector"}, {"fullname": "streamAPI.stream.TO.TerminalOperations.Reduce.__init__", "modulename": "streamAPI.stream.TO.TerminalOperations", "qualname": "Reduce.__init__", "kind": "function", "doc": "<p>Reduces Stream data.</p>\n\n<h6 id=\"parameters\">Parameters</h6>\n\n<ul>\n<li><strong>o</strong>:  initial point, defaults to NIL</li>\n<li><strong>bi_func</strong>:  reducing function</li>\n</ul>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">o</span><span class=\"o\">=&lt;</span><span class=\"nb\">object</span> <span class=\"nb\">object</span><span class=\"o\">&gt;</span>, </span><span class=\"param\"><span class=\"o\">*</span>, </span><span class=\"param\"><span class=\"n\">bi_func</span><span class=\"p\">:</span> <span class=\"n\">Callable</span><span class=\"p\">[[</span><span class=\"o\">~</span><span class=\"n\">X</span><span class=\"p\">,</span> <span class=\"o\">~</span><span class=\"n\">Y</span><span class=\"p\">],</span> <span class=\"o\">~</span><span class=\"n\">Z</span><span class=\"p\">]</span></span>)</span>"}, {"fullname": "streamAPI.stream.TO.TerminalOperations.Reduce.supply", "modulename": "streamAPI.stream.TO.TerminalOperations", "qualname": "Reduce.supply", "kind": "function", "doc": "<p>supplies a new Collector.</p>\n\n<h6 id=\"returns\">Returns</h6>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"bp\">self</span></span><span class=\"return-annotation\">) -> <span class=\"n\">streamAPI</span><span class=\"o\">.</span><span class=\"n\">stream</span><span class=\"o\">.</span><span class=\"n\">TO</span><span class=\"o\">.</span><span class=\"n\">TerminalOperations</span><span class=\"o\">.</span><span class=\"n\">Collector</span>:</span></span>", "funcdef": "def"}, {"fullname": "streamAPI.stream.TO.TerminalOperations.Reduce.consume", "modulename": "streamAPI.stream.TO.TerminalOperations", "qualname": "Reduce.consume", "kind": "function", "doc": "<p>Defines how to process a data \"e\".</p>\n\n<h6 id=\"parameters\">Parameters</h6>\n\n<ul>\n<li><strong>e</strong>: </li>\n</ul>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"bp\">self</span>, </span><span class=\"param\"><span class=\"n\">e</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "streamAPI.stream.TO.TerminalOperations.Reduce.finish", "modulename": "streamAPI.stream.TO.TerminalOperations", "qualname": "Reduce.finish", "kind": "function", "doc": "<p>defines what to return with \"consumed\" elements.</p>\n\n<h6 id=\"returns\">Returns</h6>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"bp\">self</span></span><span class=\"return-annotation\">) -> <span class=\"n\">streamAPI</span><span class=\"o\">.</span><span class=\"n\">stream</span><span class=\"o\">.</span><span class=\"n\">optional</span><span class=\"o\">.</span><span class=\"n\">Optional</span>:</span></span>", "funcdef": "def"}, {"fullname": "streamAPI.stream.TO.TerminalOperations.Summing", "modulename": "streamAPI.stream.TO.TerminalOperations", "qualname": "Summing", "kind": "class", "doc": "<p>Sums element of Stream.\nStream(range(5)).collect(Summing()) -> 10</p>\n", "bases": "Collector"}, {"fullname": "streamAPI.stream.TO.TerminalOperations.Summing.supply", "modulename": "streamAPI.stream.TO.TerminalOperations", "qualname": "Summing.supply", "kind": "function", "doc": "<p>supplies a new Collector.</p>\n\n<h6 id=\"returns\">Returns</h6>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"bp\">self</span></span><span class=\"return-annotation\">) -> <span class=\"n\">streamAPI</span><span class=\"o\">.</span><span class=\"n\">stream</span><span class=\"o\">.</span><span class=\"n\">TO</span><span class=\"o\">.</span><span class=\"n\">TerminalOperations</span><span class=\"o\">.</span><span class=\"n\">Collector</span>:</span></span>", "funcdef": "def"}, {"fullname": "streamAPI.stream.TO.TerminalOperations.Summing.consume", "modulename": "streamAPI.stream.TO.TerminalOperations", "qualname": "Summing.consume", "kind": "function", "doc": "<p>Defines how to process a data \"e\".</p>\n\n<h6 id=\"parameters\">Parameters</h6>\n\n<ul>\n<li><strong>e</strong>: </li>\n</ul>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"bp\">self</span>, </span><span class=\"param\"><span class=\"n\">e</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "streamAPI.stream.TO.TerminalOperations.Summing.finish", "modulename": "streamAPI.stream.TO.TerminalOperations", "qualname": "Summing.finish", "kind": "function", "doc": "<p>defines what to return with \"consumed\" elements.</p>\n\n<h6 id=\"returns\">Returns</h6>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"bp\">self</span></span><span class=\"return-annotation\">) -> <span class=\"n\">Union</span><span class=\"p\">[</span><span class=\"nb\">int</span><span class=\"p\">,</span> <span class=\"nb\">float</span><span class=\"p\">]</span>:</span></span>", "funcdef": "def"}, {"fullname": "streamAPI.stream.TO.TerminalOperations.ToLinkedList", "modulename": "streamAPI.stream.TO.TerminalOperations", "qualname": "ToLinkedList", "kind": "class", "doc": "<p>Puts elements into a 'deque'\nStream(range(5)).collect(ToLinkedList()) -> deque([0, 1, 2, 3, 4])</p>\n", "bases": "DataHolder"}, {"fullname": "streamAPI.stream.TO.TerminalOperations.ToLinkedList.consume", "modulename": "streamAPI.stream.TO.TerminalOperations", "qualname": "ToLinkedList.consume", "kind": "function", "doc": "<p>Defines how to process a data \"e\".</p>\n\n<h6 id=\"parameters\">Parameters</h6>\n\n<ul>\n<li><strong>e</strong>: </li>\n</ul>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"bp\">self</span>, </span><span class=\"param\"><span class=\"n\">e</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "streamAPI.stream.TO.TerminalOperations.ToList", "modulename": "streamAPI.stream.TO.TerminalOperations", "qualname": "ToList", "kind": "class", "doc": "<p>Puts elements into a 'list'.</p>\n\n<p>Stream(range(5)).collect(ToList()) -> [0, 1, 2, 3, 4]</p>\n", "bases": "DataHolder"}, {"fullname": "streamAPI.stream.TO.TerminalOperations.ToList.consume", "modulename": "streamAPI.stream.TO.TerminalOperations", "qualname": "ToList.consume", "kind": "function", "doc": "<p>Defines how to process a data \"e\".</p>\n\n<h6 id=\"parameters\">Parameters</h6>\n\n<ul>\n<li><strong>e</strong>: </li>\n</ul>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"bp\">self</span>, </span><span class=\"param\"><span class=\"n\">e</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "streamAPI.stream.TO.TerminalOperations.ToMap", "modulename": "streamAPI.stream.TO.TerminalOperations", "qualname": "ToMap", "kind": "class", "doc": "<p>Used to create map from data points.</p>\n\n<p>Stream(range(5)).collect(ToMap(lambda x:x,lambda x:x**2))\n-> {0: 0, 1: 1, 2: 4, 3: 9, 4: 16}</p>\n\n<p>Stream([1,4,2,6,1,5,6]).collect(ToMap(lambda x:x,lambda x:x**2,\n                                      merger_on_conflict=lambda o,n:o))\n-> {1: 1, 4: 16, 2: 4, 6: 36, 5: 25}</p>\n", "bases": "Collector"}, {"fullname": "streamAPI.stream.TO.TerminalOperations.ToMap.__init__", "modulename": "streamAPI.stream.TO.TerminalOperations", "qualname": "ToMap.__init__", "kind": "function", "doc": "<p></p>\n", "signature": "<span class=\"signature pdoc-code multiline\">(<span class=\"param\">\t<span class=\"n\">key_mapper</span><span class=\"p\">:</span> <span class=\"n\">Callable</span><span class=\"p\">[[</span><span class=\"o\">~</span><span class=\"n\">X</span><span class=\"p\">],</span> <span class=\"o\">~</span><span class=\"n\">Y</span><span class=\"p\">]</span>,</span><span class=\"param\">\t<span class=\"n\">value_mapper</span><span class=\"p\">:</span> <span class=\"n\">Callable</span><span class=\"p\">[[</span><span class=\"o\">~</span><span class=\"n\">X</span><span class=\"p\">],</span> <span class=\"o\">~</span><span class=\"n\">Y</span><span class=\"p\">]</span> <span class=\"o\">=</span> <span class=\"o\">&lt;</span><span class=\"n\">function</span> <span class=\"n\">identity</span><span class=\"o\">&gt;</span>,</span><span class=\"param\">\t<span class=\"n\">merger_on_conflict</span><span class=\"p\">:</span> <span class=\"n\">Callable</span><span class=\"p\">[[</span><span class=\"o\">~</span><span class=\"n\">X</span><span class=\"p\">,</span> <span class=\"o\">~</span><span class=\"n\">Y</span><span class=\"p\">],</span> <span class=\"o\">~</span><span class=\"n\">Z</span><span class=\"p\">]</span> <span class=\"o\">=</span> <span class=\"kc\">None</span></span>)</span>"}, {"fullname": "streamAPI.stream.TO.TerminalOperations.ToMap.supply", "modulename": "streamAPI.stream.TO.TerminalOperations", "qualname": "ToMap.supply", "kind": "function", "doc": "<p>supplies a new Collector.</p>\n\n<h6 id=\"returns\">Returns</h6>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"bp\">self</span></span><span class=\"return-annotation\">) -> <span class=\"n\">streamAPI</span><span class=\"o\">.</span><span class=\"n\">stream</span><span class=\"o\">.</span><span class=\"n\">TO</span><span class=\"o\">.</span><span class=\"n\">TerminalOperations</span><span class=\"o\">.</span><span class=\"n\">Collector</span>:</span></span>", "funcdef": "def"}, {"fullname": "streamAPI.stream.TO.TerminalOperations.ToMap.consume", "modulename": "streamAPI.stream.TO.TerminalOperations", "qualname": "ToMap.consume", "kind": "function", "doc": "<p>creates an Entry in with key using function '_key_mapper' and value\nusing function '_value_mapper'. Note that these key-value pairs are stored\nin a dictionary so key made must to hashable.</p>\n\n<p>In case, key has already been created with earlier element, a ValueError\nwill be thrown if \"_merge_on_conflict\" is not set, else this BiFunction\nwill be used to resolve the conflict.</p>\n\n<p>Example:\n    from streamAPI.stream import *\n    from streamAPI.stream.TO import *</p>\n\n<pre><code>Stream([1,2,3,4]).collect(ToMap(lambda x:x,lambda x:x**2))\n-&gt; {1: 1, 2: 4, 3: 9, 4: 16}\n\nStream([1,2,1,4]).collect(ToMap(lambda x:x,lambda x:x**2))\nwill throw ValueError as element '1' is present multiple times.\n\n\nStream([1,2,1,4]).collect(ToMap(lambda x:x,lambda x:x**2,lambda o,n:o))\n-&gt; {1: 1, 2: 4, 4: 16} # in case of conflict, we are using old value.\n</code></pre>\n\n<h6 id=\"parameters\">Parameters</h6>\n\n<ul>\n<li><strong>e</strong>: </li>\n</ul>\n\n<h6 id=\"returns\">Returns</h6>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"bp\">self</span>, </span><span class=\"param\"><span class=\"n\">e</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "streamAPI.stream.TO.TerminalOperations.ToMap.finish", "modulename": "streamAPI.stream.TO.TerminalOperations", "qualname": "ToMap.finish", "kind": "function", "doc": "<p>defines what to return with \"consumed\" elements.</p>\n\n<h6 id=\"returns\">Returns</h6>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"bp\">self</span></span><span class=\"return-annotation\">) -> <span class=\"nb\">dict</span>:</span></span>", "funcdef": "def"}, {"fullname": "streamAPI.stream.TO.TerminalOperations.ToSet", "modulename": "streamAPI.stream.TO.TerminalOperations", "qualname": "ToSet", "kind": "class", "doc": "<p>Puts elements into a 'set'.\nStream([1,4,2,6,1,5,6]).collect(ToSet()) -> {1, 2, 4, 5, 6}</p>\n", "bases": "DataHolder"}, {"fullname": "streamAPI.stream.TO.TerminalOperations.ToSet.consume", "modulename": "streamAPI.stream.TO.TerminalOperations", "qualname": "ToSet.consume", "kind": "function", "doc": "<p>Defines how to process a data \"e\".</p>\n\n<h6 id=\"parameters\">Parameters</h6>\n\n<ul>\n<li><strong>e</strong>: </li>\n</ul>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"bp\">self</span>, </span><span class=\"param\"><span class=\"n\">e</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "streamAPI.stream.TO.TerminalOperations.on_conflict_do_nothing", "modulename": "streamAPI.stream.TO.TerminalOperations", "qualname": "on_conflict_do_nothing", "kind": "function", "doc": "<h6 id=\"parameters\">Parameters</h6>\n\n<ul>\n<li><strong>o</strong>:  old value</li>\n<li><strong>n</strong>:  new value</li>\n</ul>\n\n<h6 id=\"returns\">Returns</h6>\n\n<blockquote>\n  <p>old value</p>\n</blockquote>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">o</span>, </span><span class=\"param\"><span class=\"n\">n</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "streamAPI.stream.decos", "modulename": "streamAPI.stream.decos", "kind": "module", "doc": "<p>author: Shiv\nemail: shivkj001@gmail.com</p>\n"}, {"fullname": "streamAPI.stream.decos.check_pipeline", "modulename": "streamAPI.stream.decos", "qualname": "check_pipeline", "kind": "function", "doc": "<p>If Stream is closed then throws an exception otherwise,\nexecute the function.</p>\n\n<h6 id=\"parameters\">Parameters</h6>\n\n<ul>\n<li><strong>func</strong>: </li>\n</ul>\n\n<h6 id=\"returns\">Returns</h6>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">func</span>, </span><span class=\"param\"><span class=\"o\">*</span><span class=\"n\">args</span>, </span><span class=\"param\"><span class=\"o\">**</span><span class=\"n\">kwargs</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "streamAPI.stream.decos.close_pipeline", "modulename": "streamAPI.stream.decos", "qualname": "close_pipeline", "kind": "function", "doc": "<p>closes stream after executing the function.</p>\n\n<h6 id=\"parameters\">Parameters</h6>\n\n<ul>\n<li><strong>func</strong>: </li>\n</ul>\n\n<h6 id=\"returns\">Returns</h6>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">func</span>, </span><span class=\"param\"><span class=\"o\">*</span><span class=\"n\">args</span>, </span><span class=\"param\"><span class=\"o\">**</span><span class=\"n\">kwargs</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "streamAPI.stream.exception", "modulename": "streamAPI.stream.exception", "kind": "module", "doc": "<p>author: Shiv\nemail: shivkj001@gmail.com</p>\n"}, {"fullname": "streamAPI.stream.exception.PipelineClosed", "modulename": "streamAPI.stream.exception", "qualname": "PipelineClosed", "kind": "class", "doc": "<p>Exception thrown in case PipeLine(for example Stream) is closed.</p>\n", "bases": "builtins.Exception"}, {"fullname": "streamAPI.stream.exception.PipelineNOTClosed", "modulename": "streamAPI.stream.exception", "qualname": "PipelineNOTClosed", "kind": "class", "doc": "<p>Exception thrown in case PipeLine is not closed.</p>\n", "bases": "builtins.Exception"}, {"fullname": "streamAPI.stream.optional", "modulename": "streamAPI.stream.optional", "kind": "module", "doc": "<p>author: Shiv\nemail: shivkj001@gmail.com</p>\n"}, {"fullname": "streamAPI.stream.optional.Optional", "modulename": "streamAPI.stream.optional", "qualname": "Optional", "kind": "class", "doc": "<p>This class wraps data. This helps avoid processing None element.</p>\n", "bases": "typing.Generic[~T]"}, {"fullname": "streamAPI.stream.optional.Optional.__init__", "modulename": "streamAPI.stream.optional", "qualname": "Optional.__init__", "kind": "function", "doc": "<p></p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">data</span><span class=\"p\">:</span> <span class=\"o\">~</span><span class=\"n\">T</span></span>)</span>"}, {"fullname": "streamAPI.stream.optional.Optional.present", "modulename": "streamAPI.stream.optional", "qualname": "Optional.present", "kind": "function", "doc": "<p>Optional(None).present() -> True\nOptional(1).present() -> True</p>\n\n<p>EMPTY.present() -> False # Only EMPTY.present() will return False.</p>\n\n<h6 id=\"returns\">Returns</h6>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"bp\">self</span></span><span class=\"return-annotation\">) -> <span class=\"nb\">bool</span>:</span></span>", "funcdef": "def"}, {"fullname": "streamAPI.stream.optional.Optional.get", "modulename": "streamAPI.stream.optional", "qualname": "Optional.get", "kind": "function", "doc": "<p>returns the contained value if this object is not EMPTY,\nelse throws ValueError</p>\n\n<h6 id=\"returns\">Returns</h6>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"bp\">self</span></span><span class=\"return-annotation\">) -> <span class=\"o\">~</span><span class=\"n\">T</span>:</span></span>", "funcdef": "def"}, {"fullname": "streamAPI.stream.optional.Optional.if_present", "modulename": "streamAPI.stream.optional", "qualname": "Optional.if_present", "kind": "function", "doc": "<p>processes data only if this object is not EMPTY</p>\n\n<h6 id=\"parameters\">Parameters</h6>\n\n<ul>\n<li><strong>consumer</strong>: </li>\n</ul>\n\n<h6 id=\"returns\">Returns</h6>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"bp\">self</span>, </span><span class=\"param\"><span class=\"n\">consumer</span><span class=\"p\">:</span> <span class=\"n\">Callable</span><span class=\"p\">[[</span><span class=\"o\">~</span><span class=\"n\">T</span><span class=\"p\">],</span> <span class=\"n\">NoneType</span><span class=\"p\">]</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "streamAPI.stream.optional.Optional.or_else", "modulename": "streamAPI.stream.optional", "qualname": "Optional.or_else", "kind": "function", "doc": "<p>returns \"other\" in case this object is EMPTY else contained Object</p>\n\n<h6 id=\"parameters\">Parameters</h6>\n\n<ul>\n<li><strong>other</strong>: </li>\n</ul>\n\n<h6 id=\"returns\">Returns</h6>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"bp\">self</span>, </span><span class=\"param\"><span class=\"n\">other</span><span class=\"p\">:</span> <span class=\"o\">~</span><span class=\"n\">X</span></span><span class=\"return-annotation\">) -> <span class=\"n\">Union</span><span class=\"p\">[</span><span class=\"o\">~</span><span class=\"n\">T</span><span class=\"p\">,</span> <span class=\"o\">~</span><span class=\"n\">X</span><span class=\"p\">]</span>:</span></span>", "funcdef": "def"}, {"fullname": "streamAPI.stream.optional.Optional.or_raise", "modulename": "streamAPI.stream.optional", "qualname": "Optional.or_raise", "kind": "function", "doc": "<p>return contained value if this object is not EMPTY else\nraises the \"exception\"</p>\n\n<h6 id=\"parameters\">Parameters</h6>\n\n<ul>\n<li><strong>exception</strong>: </li>\n</ul>\n\n<h6 id=\"returns\">Returns</h6>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"bp\">self</span>, </span><span class=\"param\"><span class=\"n\">exception</span><span class=\"p\">:</span> <span class=\"ne\">Exception</span></span><span class=\"return-annotation\">) -> <span class=\"o\">~</span><span class=\"n\">T</span>:</span></span>", "funcdef": "def"}, {"fullname": "streamAPI.stream.optional.EMPTY", "modulename": "streamAPI.stream.optional", "qualname": "EMPTY", "kind": "variable", "doc": "<p></p>\n", "default_value": "EMPTY"}, {"fullname": "streamAPI.stream.optional.create_optional", "modulename": "streamAPI.stream.optional", "qualname": "create_optional", "kind": "function", "doc": "<p></p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">e</span>, </span><span class=\"param\"><span class=\"n\">sentinel</span><span class=\"o\">=&lt;</span><span class=\"nb\">object</span> <span class=\"nb\">object</span><span class=\"o\">&gt;</span></span><span class=\"return-annotation\">) -> <span class=\"n\">streamAPI</span><span class=\"o\">.</span><span class=\"n\">stream</span><span class=\"o\">.</span><span class=\"n\">optional</span><span class=\"o\">.</span><span class=\"n\">Optional</span>:</span></span>", "funcdef": "def"}, {"fullname": "streamAPI.stream.parallelStream", "modulename": "streamAPI.stream.parallelStream", "kind": "module", "doc": "<p>author: Shiv\nemail: shivkj001@gmail.com</p>\n"}, {"fullname": "streamAPI.stream.parallelStream.Exec", "modulename": "streamAPI.stream.parallelStream", "qualname": "Exec", "kind": "class", "doc": "<p>This class can be used to create pipeline operation on given\niterable object.</p>\n\n<p>There are two type of operation that can be performed on Stream:\n1) Intermediate (i.e. map, flat_map, filter, peek, distinct, sort, batch, cycle, take_while, drop_while etc.)\n2) Terminal (min, max, as_seq, group_by, all, any, none_match, for_each etc.)</p>\n\n<p>Until terminal operation is called, no execution takes place.\nSome of the examples are given below.</p>\n\n<p>Example:\n    from streamAPI.stream import *\n    from streamAPI.stream.TO import *\n    from operator import attrgetter,itemgetter</p>\n\n<pre><code>class Student:\n    def __init__(self, name, age, sex):\n        self.name = name\n        self.age = age\n        self.sex = sex\n\n    def get_age(self):\n        return self.age\n\n    def __str__(self):\n        return '[name='+self.name+',age='+str(self.age)+',sex='+('Male' if self.sex else 'Female')+']'\n\n    def __repr__(self):\n        return str(self)\n\nstudents = [Student('A',10,True),\n            Student('B',8,True),\n            Student('C',11,False),\n            Student('D',17,True),\n            Student('D',25,False),\n            Student('F',9,False),\n            Student('G',29,True)]\n\nStream(students).filter(lambda x:x.age&lt;20).sort(lambda x:x.age).collect(ToList())\n\n-&gt; [[name=B,age=8,sex=Male],\n    [name=F,age=9,sex=Female],\n    [name=A,age=10,sex=Male],\n    [name=C,age=11,sex=Female],\n    [name=D,age=17,sex=Male]]\n\n\nStream(students).filter(lambda x:x.age&lt;20).collect(GroupingBy(attrgetter('sex')))\n\n-&gt; {True: [[name=A,age=10,sex=Male],\n           [name=B,age=8,sex=Male],\n           [name=D,age=17,sex=Male]],\n    False: [[name=C,age=11,sex=Female],\n            [name=F,age=9,sex=Female]]}\n\nStream(range(10)).map(lambda x: x**3 - x**2).filter(lambda x: x%3 == 0).skip(3).collect(ToList())\n-&gt;  [48, 180, 294, 648]\n\nStream(range(10)).batch(3).collect(ToList()) -&gt; [(0, 1, 2), (3, 4, 5), (6, 7, 8), (9,)]\n\nStream([(0, 1, 2), (3, 4, 5), (6, 7, 8), (9,)]).flat_map().limit(6).collect(ToList())\n-&gt; [0, 1, 2, 3, 4, 5]\n\nStream(range(10)).take_while(lambda x:x&lt;5).collect(ToList()) # similar to while loop\n-&gt; [0, 1, 2, 3, 4]\n\nStream(range(10)).drop_while(lambda x:x&lt;5).collect(ToList())\n-&gt; [5, 6, 7, 8, 9]\n\nStream(range(3,9)).zip(range(4)).collect(ToList()) -&gt; [(3, 0), (4, 1), (5, 2), (6, 3)]\n\nStream(range(3,9)).zip(range(4),after=False).collect(ToList()) -&gt; [(0, 3), (1, 4), (2, 5), (3, 6)]\n\nStream(range(3,9)).zip_longest(range(4),fillvalue=-1).collect(ToList())\n-&gt; [(3, 0), (4, 1), (5, 2), (6, 3), (7, -1), (8, -1)]\n\nStream(range(3,9)).zip_longest(range(4),after=False,fillvalue=-1).collect(ToList())\n-&gt; [(0, 3), (1, 4), (2, 5), (3, 6), (-1, 7), (-1, 8)]\n\nStream(range(10)).map(lambda x:x**2).reduce(bi_func=op.add) # sum of squares\n-&gt; Optional[285]\n\nStream(['AB', 'BD', 'AC', 'DE', 'BD', 'BW', 'AB']).collect(GroupingBy(itemgetter(0),\n                                                              GroupingBy(itemgetter(1),\n                                                                         Counting())))\n\n-&gt; {\n     \"A\": {\n      \"B\": 2,\n      \"C\": 1\n     },\n     \"B\": {\n      \"D\": 2,\n      \"W\": 1\n     },\n     \"D\": {\n      \"E\": 1\n     }\n    }\n</code></pre>\n", "bases": "streamAPI.stream.stream.Stream[~T]"}, {"fullname": "streamAPI.stream.parallelStream.Exec.__init__", "modulename": "streamAPI.stream.parallelStream", "qualname": "Exec.__init__", "kind": "function", "doc": "<p>Initialises executor which will be used for processing stream elements.</p>\n\n<p>If \"worker\" is None, then in case of multiprocessing number of cpu in\nthe system is used and in case of multiThreading (i.e multiprocessing = False)\n\"worker\" is 5 * cpu_count().</p>\n\n<h6 id=\"parameters\">Parameters</h6>\n\n<ul>\n<li><strong>data</strong>: </li>\n<li><strong>worker</strong>:  number of worker</li>\n<li><strong>multiprocessing</strong>:  it True then multiprocessing is used else multiThreading.</li>\n</ul>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">data</span><span class=\"p\">:</span> <span class=\"n\">Iterable</span><span class=\"p\">[</span><span class=\"o\">~</span><span class=\"n\">T</span><span class=\"p\">]</span>, </span><span class=\"param\"><span class=\"n\">worker</span><span class=\"p\">:</span> <span class=\"nb\">int</span> <span class=\"o\">=</span> <span class=\"kc\">None</span>, </span><span class=\"param\"><span class=\"n\">multiprocessing</span><span class=\"p\">:</span> <span class=\"nb\">bool</span> <span class=\"o\">=</span> <span class=\"kc\">True</span></span>)</span>"}, {"fullname": "streamAPI.stream.parallelStream.ParallelStream", "modulename": "streamAPI.stream.parallelStream", "qualname": "ParallelStream", "kind": "class", "doc": "<p>This class can be used to create pipeline operation on given\niterable object.</p>\n\n<p>There are two type of operation that can be performed on Stream:\n1) Intermediate (i.e. map, flat_map, filter, peek, distinct, sort, batch, cycle, take_while, drop_while etc.)\n2) Terminal (min, max, as_seq, group_by, all, any, none_match, for_each etc.)</p>\n\n<p>Until terminal operation is called, no execution takes place.\nSome of the examples are given below.</p>\n\n<p>Example:\n    from streamAPI.stream import *\n    from streamAPI.stream.TO import *\n    from operator import attrgetter,itemgetter</p>\n\n<pre><code>class Student:\n    def __init__(self, name, age, sex):\n        self.name = name\n        self.age = age\n        self.sex = sex\n\n    def get_age(self):\n        return self.age\n\n    def __str__(self):\n        return '[name='+self.name+',age='+str(self.age)+',sex='+('Male' if self.sex else 'Female')+']'\n\n    def __repr__(self):\n        return str(self)\n\nstudents = [Student('A',10,True),\n            Student('B',8,True),\n            Student('C',11,False),\n            Student('D',17,True),\n            Student('D',25,False),\n            Student('F',9,False),\n            Student('G',29,True)]\n\nStream(students).filter(lambda x:x.age&lt;20).sort(lambda x:x.age).collect(ToList())\n\n-&gt; [[name=B,age=8,sex=Male],\n    [name=F,age=9,sex=Female],\n    [name=A,age=10,sex=Male],\n    [name=C,age=11,sex=Female],\n    [name=D,age=17,sex=Male]]\n\n\nStream(students).filter(lambda x:x.age&lt;20).collect(GroupingBy(attrgetter('sex')))\n\n-&gt; {True: [[name=A,age=10,sex=Male],\n           [name=B,age=8,sex=Male],\n           [name=D,age=17,sex=Male]],\n    False: [[name=C,age=11,sex=Female],\n            [name=F,age=9,sex=Female]]}\n\nStream(range(10)).map(lambda x: x**3 - x**2).filter(lambda x: x%3 == 0).skip(3).collect(ToList())\n-&gt;  [48, 180, 294, 648]\n\nStream(range(10)).batch(3).collect(ToList()) -&gt; [(0, 1, 2), (3, 4, 5), (6, 7, 8), (9,)]\n\nStream([(0, 1, 2), (3, 4, 5), (6, 7, 8), (9,)]).flat_map().limit(6).collect(ToList())\n-&gt; [0, 1, 2, 3, 4, 5]\n\nStream(range(10)).take_while(lambda x:x&lt;5).collect(ToList()) # similar to while loop\n-&gt; [0, 1, 2, 3, 4]\n\nStream(range(10)).drop_while(lambda x:x&lt;5).collect(ToList())\n-&gt; [5, 6, 7, 8, 9]\n\nStream(range(3,9)).zip(range(4)).collect(ToList()) -&gt; [(3, 0), (4, 1), (5, 2), (6, 3)]\n\nStream(range(3,9)).zip(range(4),after=False).collect(ToList()) -&gt; [(0, 3), (1, 4), (2, 5), (3, 6)]\n\nStream(range(3,9)).zip_longest(range(4),fillvalue=-1).collect(ToList())\n-&gt; [(3, 0), (4, 1), (5, 2), (6, 3), (7, -1), (8, -1)]\n\nStream(range(3,9)).zip_longest(range(4),after=False,fillvalue=-1).collect(ToList())\n-&gt; [(0, 3), (1, 4), (2, 5), (3, 6), (-1, 7), (-1, 8)]\n\nStream(range(10)).map(lambda x:x**2).reduce(bi_func=op.add) # sum of squares\n-&gt; Optional[285]\n\nStream(['AB', 'BD', 'AC', 'DE', 'BD', 'BW', 'AB']).collect(GroupingBy(itemgetter(0),\n                                                              GroupingBy(itemgetter(1),\n                                                                         Counting())))\n\n-&gt; {\n     \"A\": {\n      \"B\": 2,\n      \"C\": 1\n     },\n     \"B\": {\n      \"D\": 2,\n      \"W\": 1\n     },\n     \"D\": {\n      \"E\": 1\n     }\n    }\n</code></pre>\n", "bases": "streamAPI.stream.parallelStream.Exec[~T]"}, {"fullname": "streamAPI.stream.parallelStream.ParallelStream.__init__", "modulename": "streamAPI.stream.parallelStream", "qualname": "ParallelStream.__init__", "kind": "function", "doc": "<p>Initialises executor which is used for concurrently processing\nstream elements.</p>\n\n<p>If \"worker\" is None, then in case of multiprocessing number of cpu in\nthe system is used and in case of multiThreading (i.e multiprocessing = False)\n\"worker\" is 5 * cpu_count().</p>\n\n<h6 id=\"parameters\">Parameters</h6>\n\n<ul>\n<li><strong>data</strong>: </li>\n<li><strong>worker</strong>:  number of worker</li>\n<li><strong>multiprocessing</strong>:  it True then multiprocessing is used else multiThreading.</li>\n</ul>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">data</span><span class=\"p\">:</span> <span class=\"n\">Iterable</span><span class=\"p\">[</span><span class=\"o\">~</span><span class=\"n\">T</span><span class=\"p\">]</span>, </span><span class=\"param\"><span class=\"n\">worker</span><span class=\"p\">:</span> <span class=\"nb\">int</span> <span class=\"o\">=</span> <span class=\"kc\">None</span>, </span><span class=\"param\"><span class=\"n\">multiprocessing</span><span class=\"p\">:</span> <span class=\"nb\">bool</span> <span class=\"o\">=</span> <span class=\"kc\">True</span></span>)</span>"}, {"fullname": "streamAPI.stream.parallelStream.ParallelStream.batch_processor", "modulename": "streamAPI.stream.parallelStream", "qualname": "ParallelStream.batch_processor", "kind": "function", "doc": "<p>This method is advised to be invoked when using MultiProcessing.</p>\n\n<p>Usually dispatching single unit of work (that is applying function on\na element) is less costly. So it is better to send a batch of elements to\na worker. Here \"dispatch_size\" is size of dispatch i.e. this many number\nof stream elements will be sent to each processor(worker) in one go.</p>\n\n<h6 id=\"parameters\">Parameters</h6>\n\n<ul>\n<li><strong>func</strong>: </li>\n<li><strong>dispatch_size</strong>:  number of stream elements to be given to each worker\nin one go.</li>\n<li><strong>timeout</strong>:  time to wait for task to be done, if None then there is no\nlimit on execution time.</li>\n</ul>\n\n<h6 id=\"returns\">Returns</h6>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"bp\">self</span>, </span><span class=\"param\"><span class=\"n\">func</span><span class=\"p\">:</span> <span class=\"n\">Callable</span><span class=\"p\">[[</span><span class=\"o\">~</span><span class=\"n\">T</span><span class=\"p\">],</span> <span class=\"o\">~</span><span class=\"n\">X</span><span class=\"p\">]</span>, </span><span class=\"param\"><span class=\"n\">dispatch_size</span><span class=\"p\">:</span> <span class=\"nb\">int</span>, </span><span class=\"param\"><span class=\"n\">timeout</span><span class=\"o\">=</span><span class=\"kc\">None</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "streamAPI.stream.parallelStream.ParallelStream.map_concurrent", "modulename": "streamAPI.stream.parallelStream", "qualname": "ParallelStream.map_concurrent", "kind": "function", "doc": "<p>maps elements concurrently. Elements are processed in batches of size \"batch_size\".</p>\n\n<h6 id=\"parameters\">Parameters</h6>\n\n<ul>\n<li><strong>func</strong>: </li>\n<li><strong>timeout</strong>:  time to wait for task to be done, if None then there is no\nlimit on execution time.</li>\n<li><strong>batch_size</strong>:  If it is None then number of worker is used.</li>\n</ul>\n\n<h6 id=\"returns\">Returns</h6>\n", "signature": "<span class=\"signature pdoc-code multiline\">(<span class=\"param\">\t<span class=\"bp\">self</span>,</span><span class=\"param\">\t<span class=\"n\">func</span><span class=\"p\">:</span> <span class=\"n\">Callable</span><span class=\"p\">[[</span><span class=\"o\">~</span><span class=\"n\">T</span><span class=\"p\">],</span> <span class=\"o\">~</span><span class=\"n\">X</span><span class=\"p\">]</span>,</span><span class=\"param\">\t<span class=\"n\">timeout</span><span class=\"o\">=</span><span class=\"kc\">None</span>,</span><span class=\"param\">\t<span class=\"n\">batch_size</span><span class=\"o\">=</span><span class=\"kc\">None</span></span><span class=\"return-annotation\">) -> <span class=\"n\">streamAPI</span><span class=\"o\">.</span><span class=\"n\">stream</span><span class=\"o\">.</span><span class=\"n\">parallelStream</span><span class=\"o\">.</span><span class=\"n\">ParallelStream</span><span class=\"p\">[</span><span class=\"o\">~</span><span class=\"n\">T</span><span class=\"p\">]</span>:</span></span>", "funcdef": "def"}, {"fullname": "streamAPI.stream.parallelStream.ParallelStream.filter_concurrent", "modulename": "streamAPI.stream.parallelStream", "qualname": "ParallelStream.filter_concurrent", "kind": "function", "doc": "<p>filters elements concurrently. Elements are processed in batches of size \"batch_size\".</p>\n\n<h6 id=\"parameters\">Parameters</h6>\n\n<ul>\n<li><strong>predicate</strong>: </li>\n<li><strong>timeout</strong>:  time to wait for task to be done, if None then there is no\nlimit on execution time.</li>\n<li><strong>batch_size</strong>:  If it is None then number of worker is used.</li>\n</ul>\n\n<h6 id=\"returns\">Returns</h6>\n", "signature": "<span class=\"signature pdoc-code multiline\">(<span class=\"param\">\t<span class=\"bp\">self</span>,</span><span class=\"param\">\t<span class=\"n\">predicate</span><span class=\"p\">:</span> <span class=\"n\">Callable</span><span class=\"p\">[[</span><span class=\"o\">~</span><span class=\"n\">T</span><span class=\"p\">],</span> <span class=\"nb\">bool</span><span class=\"p\">]</span>,</span><span class=\"param\">\t<span class=\"n\">timeout</span><span class=\"o\">=</span><span class=\"kc\">None</span>,</span><span class=\"param\">\t<span class=\"n\">batch_size</span><span class=\"o\">=</span><span class=\"kc\">None</span></span><span class=\"return-annotation\">) -> <span class=\"n\">streamAPI</span><span class=\"o\">.</span><span class=\"n\">stream</span><span class=\"o\">.</span><span class=\"n\">parallelStream</span><span class=\"o\">.</span><span class=\"n\">ParallelStream</span><span class=\"p\">[</span><span class=\"o\">~</span><span class=\"n\">T</span><span class=\"p\">]</span>:</span></span>", "funcdef": "def"}, {"fullname": "streamAPI.stream.parallelStream.ParallelStream.count", "modulename": "streamAPI.stream.parallelStream", "qualname": "ParallelStream.count", "kind": "function", "doc": "<p>This operation is one of the terminal operations.</p>\n\n<p>Finds number of elements in stream.</p>\n\n<p>Example:\n    Stream(range(10)).count() -> 10</p>\n\n<h6 id=\"returns\">Returns</h6>\n\n<blockquote>\n  <p>number of elements in Stream</p>\n</blockquote>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"bp\">self</span></span><span class=\"return-annotation\">) -> <span class=\"nb\">int</span>:</span></span>", "funcdef": "def"}, {"fullname": "streamAPI.stream.parallelStream.ParallelStream.min", "modulename": "streamAPI.stream.parallelStream", "qualname": "ParallelStream.min", "kind": "function", "doc": "<p>This operation is one of the terminal operations\nfinds minimum element in stream.</p>\n\n<p>Example1:\n    stream = Stream([3,1,5])\n    item = stream.min().get() -> 1</p>\n\n<p>Example2:\n    class Student:\n        def __init__(self, name, age):\n            self.name = name\n            self.age = age</p>\n\n<pre><code>    def get_age(self):\n        return self.age\n\n    def __str__(self):\n        return '[name='+self.name+',age='+str(self.age)+']'\n\n    def __repr__(self):\n        return str(self)\n\nstudents = [Student('A',3),Student('B',1),Student('C',4),Student('D',6)]\n\nStream(students).min(key=Student.get_age) -&gt; Optional[[name=B,age=1]]\n</code></pre>\n\n<h6 id=\"parameters\">Parameters</h6>\n\n<ul>\n<li><strong>key</strong>: </li>\n</ul>\n\n<h6 id=\"returns\">Returns</h6>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"bp\">self</span>, </span><span class=\"param\"><span class=\"n\">key</span><span class=\"o\">=</span><span class=\"kc\">None</span></span><span class=\"return-annotation\">) -> <span class=\"n\">streamAPI</span><span class=\"o\">.</span><span class=\"n\">stream</span><span class=\"o\">.</span><span class=\"n\">optional</span><span class=\"o\">.</span><span class=\"n\">Optional</span><span class=\"p\">[</span><span class=\"n\">typing</span><span class=\"o\">.</span><span class=\"n\">Any</span><span class=\"p\">]</span>:</span></span>", "funcdef": "def"}, {"fullname": "streamAPI.stream.parallelStream.ParallelStream.max", "modulename": "streamAPI.stream.parallelStream", "qualname": "ParallelStream.max", "kind": "function", "doc": "<p>This operation is one of the terminal operations.\nfinds maximum element in stream.</p>\n\n<p>Example1:\n    stream = Stream([3,1,5])\n    item = stream.max().get() -> 5</p>\n\n<p>Example2:\n    class Student:\n        def __init__(self, name, age):\n            self.name = name\n            self.age = age</p>\n\n<pre><code>    def get_age(self):\n        return self.age\n\n    def __str__(self):\n        return '[name='+self.name+',age='+str(self.age)+']'\n\n    def __repr__(self):\n        return str(self)\n\nstudents = [Student('A',3),Student('B',1),Student('C',4),Student('D',6)]\n\nStream(students).max(key=Student.get_age) -&gt; Optional[[name=D,age=6]]\n</code></pre>\n\n<h6 id=\"parameters\">Parameters</h6>\n\n<ul>\n<li><strong>key</strong>: </li>\n</ul>\n\n<h6 id=\"returns\">Returns</h6>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"bp\">self</span>, </span><span class=\"param\"><span class=\"n\">key</span><span class=\"o\">=</span><span class=\"kc\">None</span></span><span class=\"return-annotation\">) -> <span class=\"n\">streamAPI</span><span class=\"o\">.</span><span class=\"n\">stream</span><span class=\"o\">.</span><span class=\"n\">optional</span><span class=\"o\">.</span><span class=\"n\">Optional</span><span class=\"p\">[</span><span class=\"n\">typing</span><span class=\"o\">.</span><span class=\"n\">Any</span><span class=\"p\">]</span>:</span></span>", "funcdef": "def"}, {"fullname": "streamAPI.stream.parallelStream.ParallelStream.all", "modulename": "streamAPI.stream.parallelStream", "qualname": "ParallelStream.all", "kind": "function", "doc": "<p>This operation is one of the terminal operations.\nreturns True if all elements returns True.</p>\n\n<p>Note that, if there is no element in stream then returns True.</p>\n\n<p>Example:\n    class Student:\n        def __init__(self, name, age):\n            self.name = name\n            self.age  = age</p>\n\n<pre><code>Stream([Student('a',10), Student('b',12)]).all(predicate=lambda x:x.age &lt; 15)\n-&gt; True\n\nStream([]).all() -&gt; True # Empty Stream returns True\nStream([0]).all() -&gt; False\nStream([1]).all() -&gt; True\n</code></pre>\n\n<h6 id=\"parameters\">Parameters</h6>\n\n<ul>\n<li><strong>predicate</strong>: </li>\n</ul>\n\n<h6 id=\"returns\">Returns</h6>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"bp\">self</span>, </span><span class=\"param\"><span class=\"n\">predicate</span><span class=\"p\">:</span> <span class=\"n\">Callable</span><span class=\"p\">[[</span><span class=\"o\">~</span><span class=\"n\">X</span><span class=\"p\">],</span> <span class=\"nb\">bool</span><span class=\"p\">]</span> <span class=\"o\">=</span> <span class=\"o\">&lt;</span><span class=\"n\">function</span> <span class=\"n\">identity</span><span class=\"o\">&gt;</span></span><span class=\"return-annotation\">) -> <span class=\"nb\">bool</span>:</span></span>", "funcdef": "def"}, {"fullname": "streamAPI.stream.parallelStream.ParallelStream.any", "modulename": "streamAPI.stream.parallelStream", "qualname": "ParallelStream.any", "kind": "function", "doc": "<p>This operation is one of the terminal operations\nReturns True if at-least one element are True according to given predicate.</p>\n\n<p>Note that if there is no element in the stream then returns False.</p>\n\n<p>Example:\n    class Student:\n        def __init__(self, name, age):\n            self.name = name\n            self.age  = age</p>\n\n<pre><code>stream = Stream([Student('a',10), Student('b',12)])\nstream.any(predicate=lambda x:x.age &gt; 15) -&gt; False\n\nStream([]).any() -&gt; False\nStream([1]).any() -&gt; True\nStream([0]).any() -&gt; False\n</code></pre>\n\n<h6 id=\"parameters\">Parameters</h6>\n\n<ul>\n<li><strong>predicate</strong>: </li>\n</ul>\n\n<h6 id=\"returns\">Returns</h6>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"bp\">self</span>, </span><span class=\"param\"><span class=\"n\">predicate</span><span class=\"p\">:</span> <span class=\"n\">Callable</span><span class=\"p\">[[</span><span class=\"o\">~</span><span class=\"n\">X</span><span class=\"p\">],</span> <span class=\"nb\">bool</span><span class=\"p\">]</span> <span class=\"o\">=</span> <span class=\"o\">&lt;</span><span class=\"n\">function</span> <span class=\"n\">identity</span><span class=\"o\">&gt;</span></span><span class=\"return-annotation\">) -> <span class=\"nb\">bool</span>:</span></span>", "funcdef": "def"}, {"fullname": "streamAPI.stream.parallelStream.ParallelStream.none_match", "modulename": "streamAPI.stream.parallelStream", "qualname": "ParallelStream.none_match", "kind": "function", "doc": "<p>This operation is one of the terminal operations\nreturns True if no element are true according to predicate.</p>\n\n<p>Note that if there is no element in the stream then returns True.</p>\n\n<p>Example:\n    class Student:\n        def __init__(self, name, age):\n            self.name = name\n            self.age  = age</p>\n\n<pre><code>stream = Stream([Student('a',10), Student('b',12)])\nstream.none_match(predicate=lambda x:x.age &gt; 11) -&gt; False\n</code></pre>\n\n<p>Example:\n    stream = Stream([Student('a',10), Student('b',12)])\n    stream.none_match(predicate=lambda x:x.age &gt; 13) -> True</p>\n\n<p>Example:\n    Stream([]).none_match(lambda x: x == 5) -> True\n    Stream([1]).none_match(lambda x: x == 5) -> True\n    Stream([1,5]).none_match(lambda x: x == 5) -> False</p>\n\n<h6 id=\"parameters\">Parameters</h6>\n\n<ul>\n<li><strong>predicate</strong>: </li>\n</ul>\n\n<h6 id=\"returns\">Returns</h6>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"bp\">self</span>, </span><span class=\"param\"><span class=\"n\">predicate</span><span class=\"p\">:</span> <span class=\"n\">Callable</span><span class=\"p\">[[</span><span class=\"o\">~</span><span class=\"n\">X</span><span class=\"p\">],</span> <span class=\"nb\">bool</span><span class=\"p\">]</span> <span class=\"o\">=</span> <span class=\"o\">&lt;</span><span class=\"n\">function</span> <span class=\"n\">identity</span><span class=\"o\">&gt;</span></span><span class=\"return-annotation\">) -> <span class=\"nb\">bool</span>:</span></span>", "funcdef": "def"}, {"fullname": "streamAPI.stream.parallelStream.ParallelStream.find_first", "modulename": "streamAPI.stream.parallelStream", "qualname": "ParallelStream.find_first", "kind": "function", "doc": "<p>This operation is one of the terminal operations\nfinds first element from Stream.</p>\n\n<p>Example:\n    Stream(range(4,9)).find_first() -> Optional[4]</p>\n\n<h6 id=\"returns\">Returns</h6>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"bp\">self</span></span><span class=\"return-annotation\">) -> <span class=\"n\">streamAPI</span><span class=\"o\">.</span><span class=\"n\">stream</span><span class=\"o\">.</span><span class=\"n\">optional</span><span class=\"o\">.</span><span class=\"n\">Optional</span><span class=\"p\">[</span><span class=\"n\">typing</span><span class=\"o\">.</span><span class=\"n\">Any</span><span class=\"p\">]</span>:</span></span>", "funcdef": "def"}, {"fullname": "streamAPI.stream.parallelStream.ParallelStream.reduce", "modulename": "streamAPI.stream.parallelStream", "qualname": "ParallelStream.reduce", "kind": "function", "doc": "<p>This operation is one of the terminal operations\nreduces stream element to produce an element.</p>\n\n<p>Example:\n    import operator as op</p>\n\n<pre><code>Stream(range(1,6)).reduce(1,bi_func=op.mul).get() -&gt; 120 (factorial 5)\n</code></pre>\n\n<p>Case Without initial point(initial__pointer is NIL):\n    Return value can only be EMPTY iff Stream does not having\n    any element left in it.</p>\n\n<pre><code>Stream([]).reduce(bi_func=op.add) -&gt; EMPTY\nStream([1]).reduce(bi_func=op.add) -&gt; Optional[1]\nStream([1, 2]).reduce(bi_func=op.add) -&gt; Optional[3]\n</code></pre>\n\n<p>Case With Initial Point (initial_point is not NIL):\n    Return value will never be EMPTY.\n    initial_point = 10</p>\n\n<pre><code>Stream([]).reduce(initial_point,bi_func=op.add) -&gt; Optional[10]\nStream([1]).reduce(initial_point,bi_func=op.add) -&gt; Optional[11]\nStream([1, 2]).reduce(initial_point,bi_func=op.add) -&gt; Optional[13]\n</code></pre>\n\n<h6 id=\"parameters\">Parameters</h6>\n\n<ul>\n<li><strong>initial_point</strong>:  defaults to NIL</li>\n<li><strong>bi_func</strong>:  reduction function</li>\n</ul>\n\n<h6 id=\"returns\">Returns</h6>\n", "signature": "<span class=\"signature pdoc-code multiline\">(<span class=\"param\">\t<span class=\"bp\">self</span>,</span><span class=\"param\">\t<span class=\"n\">initial_point</span><span class=\"p\">:</span> <span class=\"o\">~</span><span class=\"n\">X</span> <span class=\"o\">=</span> <span class=\"o\">&lt;</span><span class=\"nb\">object</span> <span class=\"nb\">object</span><span class=\"o\">&gt;</span>,</span><span class=\"param\">\t<span class=\"o\">*</span>,</span><span class=\"param\">\t<span class=\"n\">bi_func</span><span class=\"p\">:</span> <span class=\"n\">Callable</span><span class=\"p\">[[</span><span class=\"o\">~</span><span class=\"n\">X</span><span class=\"p\">,</span> <span class=\"o\">~</span><span class=\"n\">X</span><span class=\"p\">],</span> <span class=\"o\">~</span><span class=\"n\">Y</span><span class=\"p\">]</span></span><span class=\"return-annotation\">) -> <span class=\"n\">streamAPI</span><span class=\"o\">.</span><span class=\"n\">stream</span><span class=\"o\">.</span><span class=\"n\">optional</span><span class=\"o\">.</span><span class=\"n\">Optional</span><span class=\"p\">[</span><span class=\"o\">~</span><span class=\"n\">Y</span><span class=\"p\">]</span>:</span></span>", "funcdef": "def"}, {"fullname": "streamAPI.stream.parallelStream.ParallelStream.for_each", "modulename": "streamAPI.stream.parallelStream", "qualname": "ParallelStream.for_each", "kind": "function", "doc": "<p>This operation is one of the terminal operations\nconsumes each element from stream.</p>\n\n<p>Example:\n    stream = Stream(range(5))\n    stream.for_each(print)\n    prints ->\n    1\n    2\n    3\n    4\n    5</p>\n\n<h6 id=\"parameters\">Parameters</h6>\n\n<ul>\n<li><strong>consumer</strong>: </li>\n</ul>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"bp\">self</span>, </span><span class=\"param\"><span class=\"n\">consumer</span><span class=\"p\">:</span> <span class=\"n\">Callable</span><span class=\"p\">[[</span><span class=\"o\">~</span><span class=\"n\">X</span><span class=\"p\">],</span> <span class=\"n\">NoneType</span><span class=\"p\">]</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "streamAPI.stream.parallelStream.ParallelStream.done", "modulename": "streamAPI.stream.parallelStream", "qualname": "ParallelStream.done", "kind": "function", "doc": "<p>This operation is one of the terminal operations.</p>\n\n<p>This can be used in case we are only interested in processing\nintermediate elements.</p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"bp\">self</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "streamAPI.stream.parallelStream.ParallelStream.collect", "modulename": "streamAPI.stream.parallelStream", "qualname": "ParallelStream.collect", "kind": "function", "doc": "<p>This operation is one of the terminal operations.\nFor more detail see: streamAPI.stream.TO package.</p>\n\n<h6 id=\"parameters\">Parameters</h6>\n\n<ul>\n<li><strong>collector</strong>: </li>\n</ul>\n\n<h6 id=\"returns\">Returns</h6>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"bp\">self</span>, </span><span class=\"param\"><span class=\"n\">collector</span><span class=\"p\">:</span> <span class=\"n\">streamAPI</span><span class=\"o\">.</span><span class=\"n\">stream</span><span class=\"o\">.</span><span class=\"n\">TO</span><span class=\"o\">.</span><span class=\"n\">TerminalOperations</span><span class=\"o\">.</span><span class=\"n\">Collector</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "streamAPI.stream.parallelStream.ParallelStream.for_each_concurrent", "modulename": "streamAPI.stream.parallelStream", "qualname": "ParallelStream.for_each_concurrent", "kind": "function", "doc": "<p>This method differs from \"for_each\" method in the way that it consumes\nstream elements concurrently.</p>\n\n<p>Example:\n    from time import sleep\n    from streamAPI.test.testHelper import random</p>\n\n<pre><code>rnd = random(seed=None)\n\ndef process(e):\n    sleep(rnd.random())\n    print(e)\n\nParallelStream(range(10)).for_each_concurrent(process)\n</code></pre>\n\n<h6 id=\"parameters\">Parameters</h6>\n\n<ul>\n<li><strong>consumer</strong>:  function to consume stream elements.</li>\n<li><strong>timeout</strong>:  if None, there is no limit on execution time.</li>\n<li><strong>batch_size</strong>:  If it is None then number of worker is used.</li>\n</ul>\n", "signature": "<span class=\"signature pdoc-code multiline\">(<span class=\"param\">\t<span class=\"bp\">self</span>,</span><span class=\"param\">\t<span class=\"n\">consumer</span><span class=\"p\">:</span> <span class=\"n\">Callable</span><span class=\"p\">[[</span><span class=\"o\">~</span><span class=\"n\">X</span><span class=\"p\">],</span> <span class=\"n\">NoneType</span><span class=\"p\">]</span>,</span><span class=\"param\">\t<span class=\"n\">timeout</span><span class=\"o\">=</span><span class=\"kc\">None</span>,</span><span class=\"param\">\t<span class=\"n\">batch_size</span><span class=\"o\">=</span><span class=\"kc\">None</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "streamAPI.stream.stream", "modulename": "streamAPI.stream.stream", "kind": "module", "doc": "<p>author: Shiv\nemail: shivkj001@gmail.com</p>\n"}, {"fullname": "streamAPI.stream.stream.Stream", "modulename": "streamAPI.stream.stream", "qualname": "Stream", "kind": "class", "doc": "<p>This class can be used to create pipeline operation on given\niterable object.</p>\n\n<p>There are two type of operation that can be performed on Stream:\n1) Intermediate (i.e. map, flat_map, filter, peek, distinct, sort, batch, cycle, take_while, drop_while etc.)\n2) Terminal (min, max, as_seq, group_by, all, any, none_match, for_each etc.)</p>\n\n<p>Until terminal operation is called, no execution takes place.\nSome of the examples are given below.</p>\n\n<p>Example:\n    from streamAPI.stream import *\n    from streamAPI.stream.TO import *\n    from operator import attrgetter,itemgetter</p>\n\n<pre><code>class Student:\n    def __init__(self, name, age, sex):\n        self.name = name\n        self.age = age\n        self.sex = sex\n\n    def get_age(self):\n        return self.age\n\n    def __str__(self):\n        return '[name='+self.name+',age='+str(self.age)+',sex='+('Male' if self.sex else 'Female')+']'\n\n    def __repr__(self):\n        return str(self)\n\nstudents = [Student('A',10,True),\n            Student('B',8,True),\n            Student('C',11,False),\n            Student('D',17,True),\n            Student('D',25,False),\n            Student('F',9,False),\n            Student('G',29,True)]\n\nStream(students).filter(lambda x:x.age&lt;20).sort(lambda x:x.age).collect(ToList())\n\n-&gt; [[name=B,age=8,sex=Male],\n    [name=F,age=9,sex=Female],\n    [name=A,age=10,sex=Male],\n    [name=C,age=11,sex=Female],\n    [name=D,age=17,sex=Male]]\n\n\nStream(students).filter(lambda x:x.age&lt;20).collect(GroupingBy(attrgetter('sex')))\n\n-&gt; {True: [[name=A,age=10,sex=Male],\n           [name=B,age=8,sex=Male],\n           [name=D,age=17,sex=Male]],\n    False: [[name=C,age=11,sex=Female],\n            [name=F,age=9,sex=Female]]}\n\nStream(range(10)).map(lambda x: x**3 - x**2).filter(lambda x: x%3 == 0).skip(3).collect(ToList())\n-&gt;  [48, 180, 294, 648]\n\nStream(range(10)).batch(3).collect(ToList()) -&gt; [(0, 1, 2), (3, 4, 5), (6, 7, 8), (9,)]\n\nStream([(0, 1, 2), (3, 4, 5), (6, 7, 8), (9,)]).flat_map().limit(6).collect(ToList())\n-&gt; [0, 1, 2, 3, 4, 5]\n\nStream(range(10)).take_while(lambda x:x&lt;5).collect(ToList()) # similar to while loop\n-&gt; [0, 1, 2, 3, 4]\n\nStream(range(10)).drop_while(lambda x:x&lt;5).collect(ToList())\n-&gt; [5, 6, 7, 8, 9]\n\nStream(range(3,9)).zip(range(4)).collect(ToList()) -&gt; [(3, 0), (4, 1), (5, 2), (6, 3)]\n\nStream(range(3,9)).zip(range(4),after=False).collect(ToList()) -&gt; [(0, 3), (1, 4), (2, 5), (3, 6)]\n\nStream(range(3,9)).zip_longest(range(4),fillvalue=-1).collect(ToList())\n-&gt; [(3, 0), (4, 1), (5, 2), (6, 3), (7, -1), (8, -1)]\n\nStream(range(3,9)).zip_longest(range(4),after=False,fillvalue=-1).collect(ToList())\n-&gt; [(0, 3), (1, 4), (2, 5), (3, 6), (-1, 7), (-1, 8)]\n\nStream(range(10)).map(lambda x:x**2).reduce(bi_func=op.add) # sum of squares\n-&gt; Optional[285]\n\nStream(['AB', 'BD', 'AC', 'DE', 'BD', 'BW', 'AB']).collect(GroupingBy(itemgetter(0),\n                                                              GroupingBy(itemgetter(1),\n                                                                         Counting())))\n\n-&gt; {\n     \"A\": {\n      \"B\": 2,\n      \"C\": 1\n     },\n     \"B\": {\n      \"D\": 2,\n      \"W\": 1\n     },\n     \"D\": {\n      \"E\": 1\n     }\n    }\n</code></pre>\n", "bases": "streamAPI.stream.streamHelper.Closable, typing.Generic[~X]"}, {"fullname": "streamAPI.stream.stream.Stream.from_supplier", "modulename": "streamAPI.stream.stream", "qualname": "Stream.from_supplier", "kind": "function", "doc": "<p>Generates a stream from a callable function.(see Supplier class in\nstreamHelper module for more detail).</p>\n\n<h6 id=\"parameters\">Parameters</h6>\n\n<ul>\n<li><strong>func</strong>: </li>\n</ul>\n\n<h6 id=\"returns\">Returns</h6>\n\n<blockquote>\n  <p>a new Stream class object.</p>\n</blockquote>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"bp\">cls</span>, </span><span class=\"param\"><span class=\"n\">func</span><span class=\"p\">:</span> <span class=\"n\">Callable</span><span class=\"p\">[[],</span> <span class=\"o\">~</span><span class=\"n\">X</span><span class=\"p\">]</span></span><span class=\"return-annotation\">) -> <span class=\"n\">streamAPI</span><span class=\"o\">.</span><span class=\"n\">stream</span><span class=\"o\">.</span><span class=\"n\">stream</span><span class=\"o\">.</span><span class=\"n\">Stream</span><span class=\"p\">[</span><span class=\"o\">~</span><span class=\"n\">X</span><span class=\"p\">]</span>:</span></span>", "funcdef": "def"}, {"fullname": "streamAPI.stream.stream.Stream.map", "modulename": "streamAPI.stream.stream", "qualname": "Stream.map", "kind": "function", "doc": "<p>maps elements of stream and produces stream of mapped element.</p>\n\n<p>Example:\n    stream = Stream(range(5)).map(lambda x: 2*x)\n    print(list(stream)) # prints [0, 2, 4, 6, 8]</p>\n\n<h6 id=\"parameters\">Parameters</h6>\n\n<ul>\n<li><strong>func</strong>: </li>\n</ul>\n\n<h6 id=\"returns\">Returns</h6>\n\n<blockquote>\n  <p>Stream itself</p>\n</blockquote>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"bp\">self</span>, </span><span class=\"param\"><span class=\"n\">func</span><span class=\"p\">:</span> <span class=\"n\">Callable</span><span class=\"p\">[[</span><span class=\"o\">~</span><span class=\"n\">X</span><span class=\"p\">],</span> <span class=\"o\">~</span><span class=\"n\">Y</span><span class=\"p\">]</span></span><span class=\"return-annotation\">) -> <span class=\"n\">streamAPI</span><span class=\"o\">.</span><span class=\"n\">stream</span><span class=\"o\">.</span><span class=\"n\">stream</span><span class=\"o\">.</span><span class=\"n\">Stream</span><span class=\"p\">[</span><span class=\"o\">~</span><span class=\"n\">Y</span><span class=\"p\">]</span>:</span></span>", "funcdef": "def"}, {"fullname": "streamAPI.stream.stream.Stream.filter", "modulename": "streamAPI.stream.stream", "qualname": "Stream.filter", "kind": "function", "doc": "<p>Filters elements from Stream, i.e. if predicates evaluates an\nelement as False, then the elements is not considered for\nfurther processing.</p>\n\n<p>Example:\n    stream = Stream(range(5)).filter(lambda x: x%2 == 1)\n    print(list(stream)) # prints [1, 3]</p>\n\n<h6 id=\"parameters\">Parameters</h6>\n\n<ul>\n<li><strong>predicate</strong>: </li>\n</ul>\n\n<h6 id=\"returns\">Returns</h6>\n\n<blockquote>\n  <p>Stream itself</p>\n</blockquote>\n", "signature": "<span class=\"signature pdoc-code multiline\">(<span class=\"param\">\t<span class=\"bp\">self</span>,</span><span class=\"param\">\t<span class=\"n\">predicate</span><span class=\"p\">:</span> <span class=\"n\">Callable</span><span class=\"p\">[[</span><span class=\"o\">~</span><span class=\"n\">X</span><span class=\"p\">],</span> <span class=\"nb\">bool</span><span class=\"p\">]</span></span><span class=\"return-annotation\">) -> <span class=\"n\">streamAPI</span><span class=\"o\">.</span><span class=\"n\">stream</span><span class=\"o\">.</span><span class=\"n\">stream</span><span class=\"o\">.</span><span class=\"n\">Stream</span><span class=\"p\">[</span><span class=\"o\">~</span><span class=\"n\">X</span><span class=\"p\">]</span>:</span></span>", "funcdef": "def"}, {"fullname": "streamAPI.stream.stream.Stream.exclude", "modulename": "streamAPI.stream.stream", "qualname": "Stream.exclude", "kind": "function", "doc": "<p>Excluding an element from the stream if 'predicate' returns True for\nit.</p>\n\n<p>from streamAPI.stream import *</p>\n\n<p>def is_odd(x): return x%2==1</p>\n\n<p>Stream(range(10)).exclude(is_odd).collect(TO.ToList())\n-> [0, 2, 4, 6, 8] # every odd number will be excluded.</p>\n\n<h6 id=\"parameters\">Parameters</h6>\n\n<ul>\n<li><strong>predicate</strong>: </li>\n</ul>\n\n<h6 id=\"returns\">Returns</h6>\n\n<blockquote>\n  <p>Stream itself</p>\n</blockquote>\n", "signature": "<span class=\"signature pdoc-code multiline\">(<span class=\"param\">\t<span class=\"bp\">self</span>,</span><span class=\"param\">\t<span class=\"n\">predicate</span><span class=\"p\">:</span> <span class=\"n\">Callable</span><span class=\"p\">[[</span><span class=\"o\">~</span><span class=\"n\">X</span><span class=\"p\">],</span> <span class=\"nb\">bool</span><span class=\"p\">]</span></span><span class=\"return-annotation\">) -> <span class=\"n\">streamAPI</span><span class=\"o\">.</span><span class=\"n\">stream</span><span class=\"o\">.</span><span class=\"n\">stream</span><span class=\"o\">.</span><span class=\"n\">Stream</span><span class=\"p\">[</span><span class=\"o\">~</span><span class=\"n\">X</span><span class=\"p\">]</span>:</span></span>", "funcdef": "def"}, {"fullname": "streamAPI.stream.stream.Stream.sort", "modulename": "streamAPI.stream.stream", "qualname": "Stream.sort", "kind": "function", "doc": "<p>Sorts element of Stream.</p>\n\n<p>Example1:\n    stream = Stream([3,1,4,6]).sort()\n    list(stream) -> [1, 3, 4, 6]</p>\n\n<pre><code>Stream([3,1,4,6]).sort(reverse=True).collect(ToList()) -&gt; [6, 4, 3, 1]\n</code></pre>\n\n<p>Example2:\n    class Student:\n        def __init__(self, name, age):\n            self.name = name\n            self.age = age</p>\n\n<pre><code>    def get_age(self):\n        return self.age\n\n    def __str__(self):\n        return '[name='+self.name+',age='+str(self.age)+']'\n\n    def __repr__(self):\n        return str(self)\n\nstudents = [Student('A',3),Student('B',1),Student('C',4),Student('D',6)]\n\nStream(students).sorted(key=Student.get_age,reverse=True).collect(ToList())\n-&gt; [[name=D,age=6], [name=C,age=4], [name=A,age=3], [name=B,age=1]]\n</code></pre>\n\n<h6 id=\"parameters\">Parameters</h6>\n\n<ul>\n<li><strong>key</strong>: </li>\n<li><strong>reverse</strong>: </li>\n</ul>\n\n<h6 id=\"returns\">Returns</h6>\n\n<blockquote>\n  <p>Stream itself</p>\n</blockquote>\n", "signature": "<span class=\"signature pdoc-code multiline\">(<span class=\"param\">\t<span class=\"bp\">self</span>,</span><span class=\"param\">\t<span class=\"n\">key</span><span class=\"o\">=</span><span class=\"kc\">None</span>,</span><span class=\"param\">\t<span class=\"n\">reverse</span><span class=\"p\">:</span> <span class=\"nb\">bool</span> <span class=\"o\">=</span> <span class=\"kc\">False</span></span><span class=\"return-annotation\">) -> <span class=\"n\">streamAPI</span><span class=\"o\">.</span><span class=\"n\">stream</span><span class=\"o\">.</span><span class=\"n\">stream</span><span class=\"o\">.</span><span class=\"n\">Stream</span><span class=\"p\">[</span><span class=\"o\">~</span><span class=\"n\">X</span><span class=\"p\">]</span>:</span></span>", "funcdef": "def"}, {"fullname": "streamAPI.stream.stream.Stream.distinct", "modulename": "streamAPI.stream.stream", "qualname": "Stream.distinct", "kind": "function", "doc": "<p>uses distinct element of for further processing.</p>\n\n<p>Example:\n    stream = Stream([4,1,6,1]).distinct()\n    list(stream) -> [1, 4, 6]</p>\n\n<p>Note that, sorting is not guaranteed.\nElements must be hashable and define equal logic(__eq__)</p>\n\n<h6 id=\"returns\">Returns</h6>\n\n<blockquote>\n  <p>Stream itself</p>\n</blockquote>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"bp\">self</span></span><span class=\"return-annotation\">) -> <span class=\"n\">streamAPI</span><span class=\"o\">.</span><span class=\"n\">stream</span><span class=\"o\">.</span><span class=\"n\">stream</span><span class=\"o\">.</span><span class=\"n\">Stream</span><span class=\"p\">[</span><span class=\"o\">~</span><span class=\"n\">X</span><span class=\"p\">]</span>:</span></span>", "funcdef": "def"}, {"fullname": "streamAPI.stream.stream.Stream.limit", "modulename": "streamAPI.stream.stream", "qualname": "Stream.limit", "kind": "function", "doc": "<p>limits number of elements for further processing.</p>\n\n<p>Example:\n    stream = Stream(range(10)).limit(3)\n    list(stream) -> [0,1,2]</p>\n\n<h6 id=\"parameters\">Parameters</h6>\n\n<ul>\n<li><strong>n</strong>:  maximum number of elements to be considered.</li>\n</ul>\n\n<h6 id=\"returns\">Returns</h6>\n\n<blockquote>\n  <p>Stream itself</p>\n</blockquote>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"bp\">self</span>, </span><span class=\"param\"><span class=\"n\">n</span><span class=\"p\">:</span> <span class=\"nb\">int</span></span><span class=\"return-annotation\">) -> <span class=\"n\">streamAPI</span><span class=\"o\">.</span><span class=\"n\">stream</span><span class=\"o\">.</span><span class=\"n\">stream</span><span class=\"o\">.</span><span class=\"n\">Stream</span><span class=\"p\">[</span><span class=\"o\">~</span><span class=\"n\">X</span><span class=\"p\">]</span>:</span></span>", "funcdef": "def"}, {"fullname": "streamAPI.stream.stream.Stream.peek", "modulename": "streamAPI.stream.stream", "qualname": "Stream.peek", "kind": "function", "doc": "<p>processes element while streaming.</p>\n\n<p>Example:\n    def f(x): return 2*x</p>\n\n<pre><code>stream = Stream(range(5)).peek(print).map(f)\nlist(stream) first prints 0 to 4 and then makes a list of [0, 2, 4, 6, 8]\n</code></pre>\n\n<h6 id=\"parameters\">Parameters</h6>\n\n<ul>\n<li><strong>consumer</strong>: </li>\n</ul>\n\n<h6 id=\"returns\">Returns</h6>\n\n<blockquote>\n  <p>Stream itself</p>\n</blockquote>\n", "signature": "<span class=\"signature pdoc-code multiline\">(<span class=\"param\">\t<span class=\"bp\">self</span>,</span><span class=\"param\">\t<span class=\"n\">consumer</span><span class=\"p\">:</span> <span class=\"n\">Callable</span><span class=\"p\">[[</span><span class=\"o\">~</span><span class=\"n\">X</span><span class=\"p\">],</span> <span class=\"n\">NoneType</span><span class=\"p\">]</span></span><span class=\"return-annotation\">) -> <span class=\"n\">streamAPI</span><span class=\"o\">.</span><span class=\"n\">stream</span><span class=\"o\">.</span><span class=\"n\">stream</span><span class=\"o\">.</span><span class=\"n\">Stream</span><span class=\"p\">[</span><span class=\"o\">~</span><span class=\"n\">X</span><span class=\"p\">]</span>:</span></span>", "funcdef": "def"}, {"fullname": "streamAPI.stream.stream.Stream.peek_after_each", "modulename": "streamAPI.stream.stream", "qualname": "Stream.peek_after_each", "kind": "function", "doc": "<p>processes element while streaming. Consumer is called after each nth item.</p>\n\n<pre><code>    Example:\n        def f(x): return 2*x\n\n        stream = Stream(range(10)).peek_after_each(print,3).map(f)\n        list(stream) first prints \"2\n</code></pre>\n\n<p>5\n8\" and then makes a list\n            [0, 2, 4, 6, 8, 10, 12, 14, 16, 18]</p>\n\n<pre><code>    :param consumer:\n    :param n: invoking the consumer after each 'n'.\n    :return: Stream itself\n</code></pre>\n", "signature": "<span class=\"signature pdoc-code multiline\">(<span class=\"param\">\t<span class=\"bp\">self</span>,</span><span class=\"param\">\t<span class=\"n\">consumer</span><span class=\"p\">:</span> <span class=\"n\">Callable</span><span class=\"p\">[[</span><span class=\"o\">~</span><span class=\"n\">X</span><span class=\"p\">],</span> <span class=\"n\">NoneType</span><span class=\"p\">]</span>,</span><span class=\"param\">\t<span class=\"n\">n</span><span class=\"p\">:</span> <span class=\"nb\">int</span></span><span class=\"return-annotation\">) -> <span class=\"n\">streamAPI</span><span class=\"o\">.</span><span class=\"n\">stream</span><span class=\"o\">.</span><span class=\"n\">stream</span><span class=\"o\">.</span><span class=\"n\">Stream</span><span class=\"p\">[</span><span class=\"o\">~</span><span class=\"n\">X</span><span class=\"p\">]</span>:</span></span>", "funcdef": "def"}, {"fullname": "streamAPI.stream.stream.Stream.skip", "modulename": "streamAPI.stream.stream", "qualname": "Stream.skip", "kind": "function", "doc": "<p>Skips \"n\" number of elements for further processing.</p>\n\n<p>Example:\n    stream = Stream(range(10)).skip(7)\n    list(stream) -> [7, 8, 9]</p>\n\n<h6 id=\"parameters\">Parameters</h6>\n\n<ul>\n<li><strong>n</strong>: </li>\n</ul>\n\n<h6 id=\"returns\">Returns</h6>\n\n<blockquote>\n  <p>Stream itself</p>\n</blockquote>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"bp\">self</span>, </span><span class=\"param\"><span class=\"n\">n</span><span class=\"p\">:</span> <span class=\"nb\">int</span></span><span class=\"return-annotation\">) -> <span class=\"n\">streamAPI</span><span class=\"o\">.</span><span class=\"n\">stream</span><span class=\"o\">.</span><span class=\"n\">stream</span><span class=\"o\">.</span><span class=\"n\">Stream</span><span class=\"p\">[</span><span class=\"o\">~</span><span class=\"n\">X</span><span class=\"p\">]</span>:</span></span>", "funcdef": "def"}, {"fullname": "streamAPI.stream.stream.Stream.flat_map", "modulename": "streamAPI.stream.stream", "qualname": "Stream.flat_map", "kind": "function", "doc": "<p>flats Stream of Iterable.</p>\n\n<p>Example:\n    stream = Stream([[1,2],[3,4,5]]).flat_map()\n    list(stream) -> [1, 2, 3, 4, 5]</p>\n\n<h6 id=\"returns\">Returns</h6>\n\n<blockquote>\n  <p>Stream itself</p>\n</blockquote>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"bp\">self</span></span><span class=\"return-annotation\">) -> <span class=\"n\">streamAPI</span><span class=\"o\">.</span><span class=\"n\">stream</span><span class=\"o\">.</span><span class=\"n\">stream</span><span class=\"o\">.</span><span class=\"n\">Stream</span><span class=\"p\">[</span><span class=\"o\">~</span><span class=\"n\">X</span><span class=\"p\">]</span>:</span></span>", "funcdef": "def"}, {"fullname": "streamAPI.stream.stream.Stream.batch", "modulename": "streamAPI.stream.stream", "qualname": "Stream.batch", "kind": "function", "doc": "<p>creates batches of size \"n\" for further processing.</p>\n\n<p>Example:\n    Stream(range(10)).batch(3).collect(ToList())\n    -> [(0, 1, 2), (3, 4, 5), (6, 7, 8), (9,)]</p>\n\n<h6 id=\"parameters\">Parameters</h6>\n\n<ul>\n<li><strong>n</strong>:  batch size</li>\n</ul>\n\n<h6 id=\"returns\">Returns</h6>\n\n<blockquote>\n  <p>Stream itself</p>\n</blockquote>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"bp\">self</span>, </span><span class=\"param\"><span class=\"n\">n</span><span class=\"p\">:</span> <span class=\"nb\">int</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "streamAPI.stream.stream.Stream.enumerate", "modulename": "streamAPI.stream.stream", "qualname": "Stream.enumerate", "kind": "function", "doc": "<p>create stream of tuples where first entry is the index and\nanother is stream element.</p>\n\n<p>Example:\n    Stream(range(4,10)).enumerate().collect(ToList())\n    -> [(0, 4), (1, 5), (2, 6), (3, 7), (4, 8), (5, 9)]</p>\n\n<pre><code>Stream(range(4,10)).enumerate(10).collect(ToList())\n [(10, 4), (11, 5), (12, 6), (13, 7), (14, 8), (15, 9)]\n</code></pre>\n\n<p>:param start</p>\n\n<h6 id=\"returns\">Returns</h6>\n\n<blockquote>\n  <p>Stream itself</p>\n</blockquote>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"bp\">self</span>, </span><span class=\"param\"><span class=\"n\">start</span><span class=\"o\">=</span><span class=\"mi\">0</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "streamAPI.stream.stream.Stream.take_while", "modulename": "streamAPI.stream.stream", "qualname": "Stream.take_while", "kind": "function", "doc": "<p>processes the element of stream till the predicate returns True.\nIt is similar to \"while\" keyword.</p>\n\n<p>Stream(range(10)).till(lambda x:x &lt; 5).collect(ToList()) -> [0,1,2,3,4]</p>\n\n<h6 id=\"parameters\">Parameters</h6>\n\n<ul>\n<li><strong>predicate</strong>: </li>\n</ul>\n\n<h6 id=\"returns\">Returns</h6>\n\n<blockquote>\n  <p>Stream itself</p>\n</blockquote>\n", "signature": "<span class=\"signature pdoc-code multiline\">(<span class=\"param\">\t<span class=\"bp\">self</span>,</span><span class=\"param\">\t<span class=\"n\">predicate</span><span class=\"p\">:</span> <span class=\"n\">Callable</span><span class=\"p\">[[</span><span class=\"o\">~</span><span class=\"n\">X</span><span class=\"p\">],</span> <span class=\"nb\">bool</span><span class=\"p\">]</span></span><span class=\"return-annotation\">) -> <span class=\"n\">streamAPI</span><span class=\"o\">.</span><span class=\"n\">stream</span><span class=\"o\">.</span><span class=\"n\">stream</span><span class=\"o\">.</span><span class=\"n\">Stream</span><span class=\"p\">[</span><span class=\"o\">~</span><span class=\"n\">X</span><span class=\"p\">]</span>:</span></span>", "funcdef": "def"}, {"fullname": "streamAPI.stream.stream.Stream.drop_while", "modulename": "streamAPI.stream.stream", "qualname": "Stream.drop_while", "kind": "function", "doc": "<p>drops elements until predicate returns False.</p>\n\n<p>stream.Stream(range(10)).drop_while(lambda x : x &lt; 5).collect(ToList()) -> [5, 6, 7, 8, 9]</p>\n\n<h6 id=\"parameters\">Parameters</h6>\n\n<ul>\n<li><strong>predicate</strong>: </li>\n</ul>\n\n<h6 id=\"returns\">Returns</h6>\n\n<blockquote>\n  <p>Stream itself</p>\n</blockquote>\n", "signature": "<span class=\"signature pdoc-code multiline\">(<span class=\"param\">\t<span class=\"bp\">self</span>,</span><span class=\"param\">\t<span class=\"n\">predicate</span><span class=\"p\">:</span> <span class=\"n\">Callable</span><span class=\"p\">[[</span><span class=\"o\">~</span><span class=\"n\">X</span><span class=\"p\">],</span> <span class=\"nb\">bool</span><span class=\"p\">]</span></span><span class=\"return-annotation\">) -> <span class=\"n\">streamAPI</span><span class=\"o\">.</span><span class=\"n\">stream</span><span class=\"o\">.</span><span class=\"n\">stream</span><span class=\"o\">.</span><span class=\"n\">Stream</span><span class=\"p\">[</span><span class=\"o\">~</span><span class=\"n\">X</span><span class=\"p\">]</span>:</span></span>", "funcdef": "def"}, {"fullname": "streamAPI.stream.stream.Stream.zip", "modulename": "streamAPI.stream.stream", "qualname": "Stream.zip", "kind": "function", "doc": "<p>zips stream with another Iterable object.</p>\n\n<p>We can specify whether to zip iterable after the stream of before\nthe stream by using \"after\".</p>\n\n<p>zip operation will produce a stream which will be exhausted if either\nitr has been exhausted or underlying stream is exhausted.</p>\n\n<p>Example:\n    Stream(range(100, 100000)).zip(range(5)).collect(ToList())\n    -> [(100, 0), (101, 1), (102, 2), (103, 3), (104, 4)]</p>\n\n<pre><code>Stream(range(5)).zip(range(100, 100000)).collect(ToList())\n-&gt; [(0, 100), (1, 101), (2, 102), (3, 103), (4, 104)]\n\nStream(range(20, 30)).zip(range(5),after=False).collect(ToList())\n# data from range(5) will be used as first entry of tuple created by zipping\n# stream with iterable\n-&gt; [(0, 20), (1, 21), (2, 22), (3, 23), (4, 24)]\n</code></pre>\n\n<h6 id=\"parameters\">Parameters</h6>\n\n<ul>\n<li><strong>itr</strong>: \n:param after</li>\n</ul>\n\n<h6 id=\"returns\">Returns</h6>\n\n<blockquote>\n  <p>Stream itself</p>\n</blockquote>\n", "signature": "<span class=\"signature pdoc-code multiline\">(<span class=\"param\">\t<span class=\"bp\">self</span>,</span><span class=\"param\">\t<span class=\"o\">*</span><span class=\"n\">itr</span><span class=\"p\">:</span> <span class=\"n\">Iterable</span><span class=\"p\">[</span><span class=\"o\">~</span><span class=\"n\">Y</span><span class=\"p\">]</span>,</span><span class=\"param\">\t<span class=\"n\">after</span><span class=\"o\">=</span><span class=\"kc\">True</span></span><span class=\"return-annotation\">) -> <span class=\"n\">streamAPI</span><span class=\"o\">.</span><span class=\"n\">stream</span><span class=\"o\">.</span><span class=\"n\">stream</span><span class=\"o\">.</span><span class=\"n\">Stream</span><span class=\"p\">[</span><span class=\"n\">typing</span><span class=\"o\">.</span><span class=\"n\">Tuple</span><span class=\"p\">]</span>:</span></span>", "funcdef": "def"}, {"fullname": "streamAPI.stream.stream.Stream.zip_longest", "modulename": "streamAPI.stream.stream", "qualname": "Stream.zip_longest", "kind": "function", "doc": "<p>Unlike zip method which limits resultant stream depending on smaller iterable,\nzip_longest allow stream generator even though smaller iterable has been exhausted.\ndefault filling value will be used from \"fillvalue\".</p>\n\n<p>Example:\n    Stream(range(11, 13)).zip_longest(range(5)).collect(ToList())\n    -> [(11, 0), (12, 1), (None, 2), (None, 3), (None, 4)]</p>\n\n<pre><code>Stream(range(11, 13)).zip_longest(range(5),after=False,fillvalue=-1).collect(ToList())\n-&gt; [(0, 11), (1, 12), (2, -1), (3, -1), (4, -1)]\n</code></pre>\n\n<h6 id=\"parameters\">Parameters</h6>\n\n<ul>\n<li><strong>itr</strong>: </li>\n<li><strong>after</strong>: defaults to True</li>\n<li><strong>fillvalue</strong>:  defaults to None.</li>\n</ul>\n\n<h6 id=\"returns\">Returns</h6>\n\n<blockquote>\n  <p>Stream itself</p>\n</blockquote>\n", "signature": "<span class=\"signature pdoc-code multiline\">(<span class=\"param\">\t<span class=\"bp\">self</span>,</span><span class=\"param\">\t<span class=\"o\">*</span><span class=\"n\">itr</span><span class=\"p\">:</span> <span class=\"n\">Iterable</span><span class=\"p\">[</span><span class=\"o\">~</span><span class=\"n\">Y</span><span class=\"p\">]</span>,</span><span class=\"param\">\t<span class=\"n\">after</span><span class=\"o\">=</span><span class=\"kc\">True</span>,</span><span class=\"param\">\t<span class=\"n\">fillvalue</span><span class=\"o\">=</span><span class=\"kc\">None</span></span><span class=\"return-annotation\">) -> <span class=\"n\">streamAPI</span><span class=\"o\">.</span><span class=\"n\">stream</span><span class=\"o\">.</span><span class=\"n\">stream</span><span class=\"o\">.</span><span class=\"n\">Stream</span><span class=\"p\">[</span><span class=\"n\">typing</span><span class=\"o\">.</span><span class=\"n\">Tuple</span><span class=\"p\">]</span>:</span></span>", "funcdef": "def"}, {"fullname": "streamAPI.stream.stream.Stream.cycle", "modulename": "streamAPI.stream.stream", "qualname": "Stream.cycle", "kind": "function", "doc": "<p>Repeats iterable \"itr\" with stream until the Stream is exhausted.</p>\n\n<p>Example:\n    Stream(range(11, 16)).cycle(range(3),after=False).collect(ToList())\n    -> [(0, 11), (1, 12), (2, 13), (0, 14), (1, 15)]</p>\n\n<h6 id=\"parameters\">Parameters</h6>\n\n<ul>\n<li><strong>itr</strong>: </li>\n<li><strong>after</strong>:  defaults to True</li>\n</ul>\n\n<h6 id=\"returns\">Returns</h6>\n\n<blockquote>\n  <p>Stream itself</p>\n</blockquote>\n", "signature": "<span class=\"signature pdoc-code multiline\">(<span class=\"param\">\t<span class=\"bp\">self</span>,</span><span class=\"param\">\t<span class=\"n\">itr</span><span class=\"p\">:</span> <span class=\"n\">Iterable</span><span class=\"p\">[</span><span class=\"o\">~</span><span class=\"n\">Y</span><span class=\"p\">]</span>,</span><span class=\"param\">\t<span class=\"n\">after</span><span class=\"o\">=</span><span class=\"kc\">True</span></span><span class=\"return-annotation\">) -> <span class=\"n\">streamAPI</span><span class=\"o\">.</span><span class=\"n\">stream</span><span class=\"o\">.</span><span class=\"n\">stream</span><span class=\"o\">.</span><span class=\"n\">Stream</span><span class=\"p\">[</span><span class=\"n\">typing</span><span class=\"o\">.</span><span class=\"n\">Tuple</span><span class=\"p\">]</span>:</span></span>", "funcdef": "def"}, {"fullname": "streamAPI.stream.stream.Stream.if_else", "modulename": "streamAPI.stream.stream", "qualname": "Stream.if_else", "kind": "function", "doc": "<p>if \"if_\" returns True then elements are transformed according to \"then\" otherwise else_\nfunction is used. This method is the special case of \"conditional\" method.\n\"else_\" has default value \"identity\" which return element as it is in case \"if_\" fails;</p>\n\n<p>Example:\n    Stream(range(10)).condition(lambda x: 3 &lt;= x &lt;= 7, lambda x: 1 , lambda x: 0).collect(ToList())\n    -> [0, 0, 0, 1, 1, 1, 1, 1, 0, 0]</p>\n\n<h6 id=\"parameters\">Parameters</h6>\n\n<ul>\n<li><strong>if_</strong>: </li>\n<li><strong>then</strong>: </li>\n<li><strong>else_</strong>:  by default it returns element as it is.</li>\n</ul>\n\n<h6 id=\"returns\">Returns</h6>\n\n<blockquote>\n  <p>Stream itself</p>\n</blockquote>\n", "signature": "<span class=\"signature pdoc-code multiline\">(<span class=\"param\">\t<span class=\"bp\">self</span>,</span><span class=\"param\">\t<span class=\"n\">if_</span><span class=\"p\">:</span> <span class=\"n\">Callable</span><span class=\"p\">[[</span><span class=\"o\">~</span><span class=\"n\">X</span><span class=\"p\">],</span> <span class=\"nb\">bool</span><span class=\"p\">]</span>,</span><span class=\"param\">\t<span class=\"n\">then</span><span class=\"p\">:</span> <span class=\"n\">Callable</span><span class=\"p\">[[</span><span class=\"o\">~</span><span class=\"n\">X</span><span class=\"p\">],</span> <span class=\"o\">~</span><span class=\"n\">Y</span><span class=\"p\">]</span>,</span><span class=\"param\">\t<span class=\"n\">else_</span><span class=\"p\">:</span> <span class=\"n\">Callable</span><span class=\"p\">[[</span><span class=\"o\">~</span><span class=\"n\">X</span><span class=\"p\">],</span> <span class=\"o\">~</span><span class=\"n\">Y</span><span class=\"p\">]</span> <span class=\"o\">=</span> <span class=\"o\">&lt;</span><span class=\"n\">function</span> <span class=\"n\">identity</span><span class=\"o\">&gt;</span></span><span class=\"return-annotation\">) -> <span class=\"n\">streamAPI</span><span class=\"o\">.</span><span class=\"n\">stream</span><span class=\"o\">.</span><span class=\"n\">stream</span><span class=\"o\">.</span><span class=\"n\">Stream</span><span class=\"p\">[</span><span class=\"o\">~</span><span class=\"n\">Y</span><span class=\"p\">]</span>:</span></span>", "funcdef": "def"}, {"fullname": "streamAPI.stream.stream.Stream.conditional", "modulename": "streamAPI.stream.stream", "qualname": "Stream.conditional", "kind": "function", "doc": "<p>Transforming stream elements on the basis of given condition.</p>\n\n<p>Example:\n    conditions = (ChainedCondition().if_then(lambda x : x &lt; 3, lambda x : 0)\n                  .if_then(lambda x: x &lt; 7,lambda x: 1)\n                  .otherwise(lambda x : 2))</p>\n\n<pre><code>Stream(range(10)).conditional(condition).collect(ToList())\n-&gt;  [0, 0, 0, 1, 1, 1, 1, 2, 2, 2]\n\nconditions = (ChainedCondition().if_then(lambda x : x &lt; 3, lambda x : 0)\n  .if_then(lambda x: x &lt; 7,lambda x: 1).done())\n\nStream(range(10)).conditional(condition).collect(ToList())\n-&gt; [0, 0, 0, 1, 1, 1, 1, 7, 8, 9]\n</code></pre>\n\n<h6 id=\"parameters\">Parameters</h6>\n\n<ul>\n<li><strong>chained_condition</strong>: </li>\n</ul>\n\n<h6 id=\"returns\">Returns</h6>\n\n<blockquote>\n  <p>Stream itself</p>\n</blockquote>\n", "signature": "<span class=\"signature pdoc-code multiline\">(<span class=\"param\">\t<span class=\"bp\">self</span>,</span><span class=\"param\">\t<span class=\"n\">chained_condition</span><span class=\"p\">:</span> <span class=\"n\">streamAPI</span><span class=\"o\">.</span><span class=\"n\">stream</span><span class=\"o\">.</span><span class=\"n\">streamHelper</span><span class=\"o\">.</span><span class=\"n\">ChainedCondition</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "streamAPI.stream.stream.Stream.accumulate", "modulename": "streamAPI.stream.stream", "qualname": "Stream.accumulate", "kind": "function", "doc": "<p>accumulates stream elements using given \"bi_func\"</p>\n\n<p>Example:\n    import operator as op</p>\n\n<pre><code>Stream(range(10)).accumulate(op.add).collect(ToList())\n-&gt; [0, 1, 3, 6, 10, 15, 21, 28, 36, 45]\n\nStream(range(1,10)).accumulate(op.mul).collect(ToList())\n-&gt; [1, 2, 6, 24, 120, 720, 5040, 40320, 362880]\n</code></pre>\n\n<h6 id=\"parameters\">Parameters</h6>\n\n<ul>\n<li><strong>bi_func</strong>: </li>\n</ul>\n\n<h6 id=\"returns\">Returns</h6>\n\n<blockquote>\n  <p>Stream itself</p>\n</blockquote>\n", "signature": "<span class=\"signature pdoc-code multiline\">(<span class=\"param\">\t<span class=\"bp\">self</span>,</span><span class=\"param\">\t<span class=\"n\">bi_func</span><span class=\"p\">:</span> <span class=\"n\">Callable</span><span class=\"p\">[[</span><span class=\"o\">~</span><span class=\"n\">X</span><span class=\"p\">,</span> <span class=\"o\">~</span><span class=\"n\">X</span><span class=\"p\">],</span> <span class=\"o\">~</span><span class=\"n\">X</span><span class=\"p\">]</span></span><span class=\"return-annotation\">) -> <span class=\"n\">streamAPI</span><span class=\"o\">.</span><span class=\"n\">stream</span><span class=\"o\">.</span><span class=\"n\">stream</span><span class=\"o\">.</span><span class=\"n\">Stream</span><span class=\"p\">[</span><span class=\"o\">~</span><span class=\"n\">X</span><span class=\"p\">]</span>:</span></span>", "funcdef": "def"}, {"fullname": "streamAPI.stream.stream.Stream.window_function", "modulename": "streamAPI.stream.stream", "qualname": "Stream.window_function", "kind": "function", "doc": "<p>If \"n\" is not None (then it has to be an integer) then invoking function\n\"func\" on 'tuple' of \"n\" elements of stream. 'tuple' is made using past\nn-1 elements and 1 current element.</p>\n\n<p>If \"n\" is None, then all past values up to current value, held by a 'list',\nwill be sent to function \"func\". Note that data type 'list', a mutable object,\nis chosen to make process more memory efficient. Any change made in the 'list'\ninside \"func\" will be visible to in future call to \"func\".(a 'list' is\nmutated via 'append','clean','extend','insert','pop','remove', 'reverse',\n'sort' methods.) Each call to \"func\" will be sent the same list appended\nwith current element.</p>\n\n<p>Example1: Moving average for window size 3\n    def mean(l): return sum(l)/len(l)</p>\n\n<pre><code>Stream([1,6,2,7,3]).window_function(mean , 3).collect(ToList())\n-&gt; [3.0, 5.0, 4.0]\n</code></pre>\n\n<p>Example2: Averaging all past values:\n    def mean(l): return sum(l)/len(l)</p>\n\n<pre><code>Stream(range(1,5)).window_function(mean , None).collect(ToList())\n-&gt; [1.0, 1.5, 2.0, 2.5]\n</code></pre>\n\n<h6 id=\"parameters\">Parameters</h6>\n\n<ul>\n<li><p><strong>func</strong>:  if \"n\" is not None then, takes input, at any instant,\n         as a 'tuple' having past \"n-1\" elements appended with\n         current element.</p>\n\n<pre><code>     If \"n\" is None, the all past values in a list appended\n     with current element.\n</code></pre></li>\n<li><strong>n</strong>:  natural number or None</li>\n</ul>\n\n<h6 id=\"returns\">Returns</h6>\n\n<blockquote>\n  <p>Stream itself</p>\n</blockquote>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"bp\">self</span>, </span><span class=\"param\"><span class=\"n\">func</span>, </span><span class=\"param\"><span class=\"n\">n</span><span class=\"p\">:</span> <span class=\"n\">Optional</span><span class=\"p\">[</span><span class=\"nb\">int</span><span class=\"p\">]</span></span><span class=\"return-annotation\">) -> <span class=\"n\">streamAPI</span><span class=\"o\">.</span><span class=\"n\">stream</span><span class=\"o\">.</span><span class=\"n\">stream</span><span class=\"o\">.</span><span class=\"n\">Stream</span><span class=\"p\">[</span><span class=\"o\">~</span><span class=\"n\">X</span><span class=\"p\">]</span>:</span></span>", "funcdef": "def"}, {"fullname": "streamAPI.stream.stream.Stream.count", "modulename": "streamAPI.stream.stream", "qualname": "Stream.count", "kind": "function", "doc": "<p>This operation is one of the terminal operations.</p>\n\n<p>Finds number of elements in stream.</p>\n\n<p>Example:\n    Stream(range(10)).count() -> 10</p>\n\n<h6 id=\"returns\">Returns</h6>\n\n<blockquote>\n  <p>number of elements in Stream</p>\n</blockquote>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"bp\">self</span></span><span class=\"return-annotation\">) -> <span class=\"nb\">int</span>:</span></span>", "funcdef": "def"}, {"fullname": "streamAPI.stream.stream.Stream.min", "modulename": "streamAPI.stream.stream", "qualname": "Stream.min", "kind": "function", "doc": "<p>This operation is one of the terminal operations\nfinds minimum element in stream.</p>\n\n<p>Example1:\n    stream = Stream([3,1,5])\n    item = stream.min().get() -> 1</p>\n\n<p>Example2:\n    class Student:\n        def __init__(self, name, age):\n            self.name = name\n            self.age = age</p>\n\n<pre><code>    def get_age(self):\n        return self.age\n\n    def __str__(self):\n        return '[name='+self.name+',age='+str(self.age)+']'\n\n    def __repr__(self):\n        return str(self)\n\nstudents = [Student('A',3),Student('B',1),Student('C',4),Student('D',6)]\n\nStream(students).min(key=Student.get_age) -&gt; Optional[[name=B,age=1]]\n</code></pre>\n\n<h6 id=\"parameters\">Parameters</h6>\n\n<ul>\n<li><strong>key</strong>: </li>\n</ul>\n\n<h6 id=\"returns\">Returns</h6>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"bp\">self</span>, </span><span class=\"param\"><span class=\"n\">key</span><span class=\"o\">=</span><span class=\"kc\">None</span></span><span class=\"return-annotation\">) -> <span class=\"n\">streamAPI</span><span class=\"o\">.</span><span class=\"n\">stream</span><span class=\"o\">.</span><span class=\"n\">optional</span><span class=\"o\">.</span><span class=\"n\">Optional</span><span class=\"p\">[</span><span class=\"n\">typing</span><span class=\"o\">.</span><span class=\"n\">Any</span><span class=\"p\">]</span>:</span></span>", "funcdef": "def"}, {"fullname": "streamAPI.stream.stream.Stream.max", "modulename": "streamAPI.stream.stream", "qualname": "Stream.max", "kind": "function", "doc": "<p>This operation is one of the terminal operations.\nfinds maximum element in stream.</p>\n\n<p>Example1:\n    stream = Stream([3,1,5])\n    item = stream.max().get() -> 5</p>\n\n<p>Example2:\n    class Student:\n        def __init__(self, name, age):\n            self.name = name\n            self.age = age</p>\n\n<pre><code>    def get_age(self):\n        return self.age\n\n    def __str__(self):\n        return '[name='+self.name+',age='+str(self.age)+']'\n\n    def __repr__(self):\n        return str(self)\n\nstudents = [Student('A',3),Student('B',1),Student('C',4),Student('D',6)]\n\nStream(students).max(key=Student.get_age) -&gt; Optional[[name=D,age=6]]\n</code></pre>\n\n<h6 id=\"parameters\">Parameters</h6>\n\n<ul>\n<li><strong>key</strong>: </li>\n</ul>\n\n<h6 id=\"returns\">Returns</h6>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"bp\">self</span>, </span><span class=\"param\"><span class=\"n\">key</span><span class=\"o\">=</span><span class=\"kc\">None</span></span><span class=\"return-annotation\">) -> <span class=\"n\">streamAPI</span><span class=\"o\">.</span><span class=\"n\">stream</span><span class=\"o\">.</span><span class=\"n\">optional</span><span class=\"o\">.</span><span class=\"n\">Optional</span><span class=\"p\">[</span><span class=\"n\">typing</span><span class=\"o\">.</span><span class=\"n\">Any</span><span class=\"p\">]</span>:</span></span>", "funcdef": "def"}, {"fullname": "streamAPI.stream.stream.Stream.all", "modulename": "streamAPI.stream.stream", "qualname": "Stream.all", "kind": "function", "doc": "<p>This operation is one of the terminal operations.\nreturns True if all elements returns True.</p>\n\n<p>Note that, if there is no element in stream then returns True.</p>\n\n<p>Example:\n    class Student:\n        def __init__(self, name, age):\n            self.name = name\n            self.age  = age</p>\n\n<pre><code>Stream([Student('a',10), Student('b',12)]).all(predicate=lambda x:x.age &lt; 15)\n-&gt; True\n\nStream([]).all() -&gt; True # Empty Stream returns True\nStream([0]).all() -&gt; False\nStream([1]).all() -&gt; True\n</code></pre>\n\n<h6 id=\"parameters\">Parameters</h6>\n\n<ul>\n<li><strong>predicate</strong>: </li>\n</ul>\n\n<h6 id=\"returns\">Returns</h6>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"bp\">self</span>, </span><span class=\"param\"><span class=\"n\">predicate</span><span class=\"p\">:</span> <span class=\"n\">Callable</span><span class=\"p\">[[</span><span class=\"o\">~</span><span class=\"n\">X</span><span class=\"p\">],</span> <span class=\"nb\">bool</span><span class=\"p\">]</span> <span class=\"o\">=</span> <span class=\"o\">&lt;</span><span class=\"n\">function</span> <span class=\"n\">identity</span><span class=\"o\">&gt;</span></span><span class=\"return-annotation\">) -> <span class=\"nb\">bool</span>:</span></span>", "funcdef": "def"}, {"fullname": "streamAPI.stream.stream.Stream.any", "modulename": "streamAPI.stream.stream", "qualname": "Stream.any", "kind": "function", "doc": "<p>This operation is one of the terminal operations\nReturns True if at-least one element are True according to given predicate.</p>\n\n<p>Note that if there is no element in the stream then returns False.</p>\n\n<p>Example:\n    class Student:\n        def __init__(self, name, age):\n            self.name = name\n            self.age  = age</p>\n\n<pre><code>stream = Stream([Student('a',10), Student('b',12)])\nstream.any(predicate=lambda x:x.age &gt; 15) -&gt; False\n\nStream([]).any() -&gt; False\nStream([1]).any() -&gt; True\nStream([0]).any() -&gt; False\n</code></pre>\n\n<h6 id=\"parameters\">Parameters</h6>\n\n<ul>\n<li><strong>predicate</strong>: </li>\n</ul>\n\n<h6 id=\"returns\">Returns</h6>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"bp\">self</span>, </span><span class=\"param\"><span class=\"n\">predicate</span><span class=\"p\">:</span> <span class=\"n\">Callable</span><span class=\"p\">[[</span><span class=\"o\">~</span><span class=\"n\">X</span><span class=\"p\">],</span> <span class=\"nb\">bool</span><span class=\"p\">]</span> <span class=\"o\">=</span> <span class=\"o\">&lt;</span><span class=\"n\">function</span> <span class=\"n\">identity</span><span class=\"o\">&gt;</span></span><span class=\"return-annotation\">) -> <span class=\"nb\">bool</span>:</span></span>", "funcdef": "def"}, {"fullname": "streamAPI.stream.stream.Stream.none_match", "modulename": "streamAPI.stream.stream", "qualname": "Stream.none_match", "kind": "function", "doc": "<p>This operation is one of the terminal operations\nreturns True if no element are true according to predicate.</p>\n\n<p>Note that if there is no element in the stream then returns True.</p>\n\n<p>Example:\n    class Student:\n        def __init__(self, name, age):\n            self.name = name\n            self.age  = age</p>\n\n<pre><code>stream = Stream([Student('a',10), Student('b',12)])\nstream.none_match(predicate=lambda x:x.age &gt; 11) -&gt; False\n</code></pre>\n\n<p>Example:\n    stream = Stream([Student('a',10), Student('b',12)])\n    stream.none_match(predicate=lambda x:x.age &gt; 13) -> True</p>\n\n<p>Example:\n    Stream([]).none_match(lambda x: x == 5) -> True\n    Stream([1]).none_match(lambda x: x == 5) -> True\n    Stream([1,5]).none_match(lambda x: x == 5) -> False</p>\n\n<h6 id=\"parameters\">Parameters</h6>\n\n<ul>\n<li><strong>predicate</strong>: </li>\n</ul>\n\n<h6 id=\"returns\">Returns</h6>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"bp\">self</span>, </span><span class=\"param\"><span class=\"n\">predicate</span><span class=\"p\">:</span> <span class=\"n\">Callable</span><span class=\"p\">[[</span><span class=\"o\">~</span><span class=\"n\">X</span><span class=\"p\">],</span> <span class=\"nb\">bool</span><span class=\"p\">]</span> <span class=\"o\">=</span> <span class=\"o\">&lt;</span><span class=\"n\">function</span> <span class=\"n\">identity</span><span class=\"o\">&gt;</span></span><span class=\"return-annotation\">) -> <span class=\"nb\">bool</span>:</span></span>", "funcdef": "def"}, {"fullname": "streamAPI.stream.stream.Stream.find_first", "modulename": "streamAPI.stream.stream", "qualname": "Stream.find_first", "kind": "function", "doc": "<p>This operation is one of the terminal operations\nfinds first element from Stream.</p>\n\n<p>Example:\n    Stream(range(4,9)).find_first() -> Optional[4]</p>\n\n<h6 id=\"returns\">Returns</h6>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"bp\">self</span></span><span class=\"return-annotation\">) -> <span class=\"n\">streamAPI</span><span class=\"o\">.</span><span class=\"n\">stream</span><span class=\"o\">.</span><span class=\"n\">optional</span><span class=\"o\">.</span><span class=\"n\">Optional</span><span class=\"p\">[</span><span class=\"n\">typing</span><span class=\"o\">.</span><span class=\"n\">Any</span><span class=\"p\">]</span>:</span></span>", "funcdef": "def"}, {"fullname": "streamAPI.stream.stream.Stream.for_each", "modulename": "streamAPI.stream.stream", "qualname": "Stream.for_each", "kind": "function", "doc": "<p>This operation is one of the terminal operations\nconsumes each element from stream.</p>\n\n<p>Example:\n    stream = Stream(range(5))\n    stream.for_each(print)\n    prints ->\n    1\n    2\n    3\n    4\n    5</p>\n\n<h6 id=\"parameters\">Parameters</h6>\n\n<ul>\n<li><strong>consumer</strong>: </li>\n</ul>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"bp\">self</span>, </span><span class=\"param\"><span class=\"n\">consumer</span><span class=\"p\">:</span> <span class=\"n\">Callable</span><span class=\"p\">[[</span><span class=\"o\">~</span><span class=\"n\">X</span><span class=\"p\">],</span> <span class=\"n\">NoneType</span><span class=\"p\">]</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "streamAPI.stream.stream.Stream.reduce", "modulename": "streamAPI.stream.stream", "qualname": "Stream.reduce", "kind": "function", "doc": "<p>This operation is one of the terminal operations\nreduces stream element to produce an element.</p>\n\n<p>Example:\n    import operator as op</p>\n\n<pre><code>Stream(range(1,6)).reduce(1,bi_func=op.mul).get() -&gt; 120 (factorial 5)\n</code></pre>\n\n<p>Case Without initial point(initial__pointer is NIL):\n    Return value can only be EMPTY iff Stream does not having\n    any element left in it.</p>\n\n<pre><code>Stream([]).reduce(bi_func=op.add) -&gt; EMPTY\nStream([1]).reduce(bi_func=op.add) -&gt; Optional[1]\nStream([1, 2]).reduce(bi_func=op.add) -&gt; Optional[3]\n</code></pre>\n\n<p>Case With Initial Point (initial_point is not NIL):\n    Return value will never be EMPTY.\n    initial_point = 10</p>\n\n<pre><code>Stream([]).reduce(initial_point,bi_func=op.add) -&gt; Optional[10]\nStream([1]).reduce(initial_point,bi_func=op.add) -&gt; Optional[11]\nStream([1, 2]).reduce(initial_point,bi_func=op.add) -&gt; Optional[13]\n</code></pre>\n\n<h6 id=\"parameters\">Parameters</h6>\n\n<ul>\n<li><strong>initial_point</strong>:  defaults to NIL</li>\n<li><strong>bi_func</strong>:  reduction function</li>\n</ul>\n\n<h6 id=\"returns\">Returns</h6>\n", "signature": "<span class=\"signature pdoc-code multiline\">(<span class=\"param\">\t<span class=\"bp\">self</span>,</span><span class=\"param\">\t<span class=\"n\">initial_point</span><span class=\"p\">:</span> <span class=\"o\">~</span><span class=\"n\">X</span> <span class=\"o\">=</span> <span class=\"o\">&lt;</span><span class=\"nb\">object</span> <span class=\"nb\">object</span><span class=\"o\">&gt;</span>,</span><span class=\"param\">\t<span class=\"o\">*</span>,</span><span class=\"param\">\t<span class=\"n\">bi_func</span><span class=\"p\">:</span> <span class=\"n\">Callable</span><span class=\"p\">[[</span><span class=\"o\">~</span><span class=\"n\">X</span><span class=\"p\">,</span> <span class=\"o\">~</span><span class=\"n\">X</span><span class=\"p\">],</span> <span class=\"o\">~</span><span class=\"n\">Y</span><span class=\"p\">]</span></span><span class=\"return-annotation\">) -> <span class=\"n\">streamAPI</span><span class=\"o\">.</span><span class=\"n\">stream</span><span class=\"o\">.</span><span class=\"n\">optional</span><span class=\"o\">.</span><span class=\"n\">Optional</span><span class=\"p\">[</span><span class=\"o\">~</span><span class=\"n\">Y</span><span class=\"p\">]</span>:</span></span>", "funcdef": "def"}, {"fullname": "streamAPI.stream.stream.Stream.done", "modulename": "streamAPI.stream.stream", "qualname": "Stream.done", "kind": "function", "doc": "<p>This operation is one of the terminal operations.</p>\n\n<p>This can be used in case we are only interested in processing\nintermediate elements.</p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"bp\">self</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "streamAPI.stream.stream.Stream.collect", "modulename": "streamAPI.stream.stream", "qualname": "Stream.collect", "kind": "function", "doc": "<p>This operation is one of the terminal operations.\nFor more detail see: streamAPI.stream.TO package.</p>\n\n<h6 id=\"parameters\">Parameters</h6>\n\n<ul>\n<li><strong>collector</strong>: </li>\n</ul>\n\n<h6 id=\"returns\">Returns</h6>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"bp\">self</span>, </span><span class=\"param\"><span class=\"n\">collector</span><span class=\"p\">:</span> <span class=\"n\">streamAPI</span><span class=\"o\">.</span><span class=\"n\">stream</span><span class=\"o\">.</span><span class=\"n\">TO</span><span class=\"o\">.</span><span class=\"n\">TerminalOperations</span><span class=\"o\">.</span><span class=\"n\">Collector</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "streamAPI.stream.stream.Stream.sum", "modulename": "streamAPI.stream.stream", "qualname": "Stream.sum", "kind": "function", "doc": "<p>Summing elements of stream.</p>\n\n<p>class Number:\n    def __init__(self,num):\n        self.num=num</p>\n\n<pre><code>def __add__(self,other):\n    return Number(self.num + other.num)\n\ndef __str__(self):\n    return str(self.num)\n</code></pre>\n\n<p>data = Stream([Number(10),Number(20),Number(30)])\nstart = Number(0)\ndata.sum(start) -> 60</p>\n\n<h6 id=\"parameters\">Parameters</h6>\n\n<ul>\n<li><strong>start</strong>:  starting point to start sum</li>\n</ul>\n\n<h6 id=\"returns\">Returns</h6>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"bp\">self</span>, </span><span class=\"param\"><span class=\"n\">start</span><span class=\"p\">:</span> <span class=\"o\">~</span><span class=\"n\">X</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "streamAPI.stream.streamHelper", "modulename": "streamAPI.stream.streamHelper", "kind": "module", "doc": "<p>author: Shiv\nemail: shivkj001@gmail.com</p>\n"}, {"fullname": "streamAPI.stream.streamHelper.AbstractCondition", "modulename": "streamAPI.stream.streamHelper", "qualname": "AbstractCondition", "kind": "class", "doc": "<p>Helper class that provides a standard way to create an ABC using\ninheritance.</p>\n", "bases": "abc.ABC"}, {"fullname": "streamAPI.stream.streamHelper.AbstractCondition.apply", "modulename": "streamAPI.stream.streamHelper", "qualname": "AbstractCondition.apply", "kind": "function", "doc": "<p>Transforming the element depending on condition specified.</p>\n\n<h6 id=\"parameters\">Parameters</h6>\n\n<ul>\n<li><strong>e</strong>: </li>\n</ul>\n\n<h6 id=\"returns\">Returns</h6>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"bp\">self</span>, </span><span class=\"param\"><span class=\"n\">e</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "streamAPI.stream.streamHelper.ChainedCondition", "modulename": "streamAPI.stream.streamHelper", "qualname": "ChainedCondition", "kind": "class", "doc": "<p>This class will help Stream in transforming elements on the basis\nof conditions.</p>\n\n<p>def transform(x):\n    if predicate1(x):\n        return f1(x)\n    elif predicate2(x):\n        return f2(x)\n    .\n    .\n    .\n    else:\n        return fn(x)</p>\n\n<p>That is equivalent to:</p>\n\n<p>ChainedCondition().if_then(predicate1,f1).if_then(predicate2,f2). ... .otherwise(fn)</p>\n\n<p>Note that before applying element, chainedCondition must be closed; ChainedCondition\ncan be closed by invoking \"otherwise\" or \"done\" method.</p>\n\n<p>If \"done\" method has been chosen to close the Pipeline and if no condition\ndefined by ChainedCondition object returns True then element itself is returned.</p>\n", "bases": "Closable, AbstractCondition"}, {"fullname": "streamAPI.stream.streamHelper.ChainedCondition.__init__", "modulename": "streamAPI.stream.streamHelper", "qualname": "ChainedCondition.__init__", "kind": "function", "doc": "<p></p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">name</span><span class=\"o\">=</span><span class=\"kc\">None</span></span>)</span>"}, {"fullname": "streamAPI.stream.streamHelper.ChainedCondition.if_else", "modulename": "streamAPI.stream.streamHelper", "qualname": "ChainedCondition.if_else", "kind": "function", "doc": "<p>Creates a ChainedCondition.</p>\n\n<p>If \"if_\" returns True on an element then ChainedCondition\nwill return \"then(element)\" otherwise else_(element) will be returned\non invoking \"apply\" method on this class object.</p>\n\n<h6 id=\"parameters\">Parameters</h6>\n\n<ul>\n<li><strong>if_</strong>: </li>\n<li><strong>then</strong>: </li>\n<li><strong>else_</strong>: </li>\n</ul>\n\n<h6 id=\"returns\">Returns</h6>\n", "signature": "<span class=\"signature pdoc-code multiline\">(<span class=\"param\">\t<span class=\"bp\">cls</span>,</span><span class=\"param\">\t<span class=\"n\">if_</span><span class=\"p\">:</span> <span class=\"n\">Callable</span><span class=\"p\">[[</span><span class=\"o\">~</span><span class=\"n\">X</span><span class=\"p\">],</span> <span class=\"nb\">bool</span><span class=\"p\">]</span>,</span><span class=\"param\">\t<span class=\"n\">then</span><span class=\"p\">:</span> <span class=\"n\">Callable</span><span class=\"p\">[[</span><span class=\"o\">~</span><span class=\"n\">X</span><span class=\"p\">],</span> <span class=\"o\">~</span><span class=\"n\">Y</span><span class=\"p\">]</span>,</span><span class=\"param\">\t<span class=\"n\">else_</span><span class=\"p\">:</span> <span class=\"n\">Callable</span><span class=\"p\">[[</span><span class=\"o\">~</span><span class=\"n\">X</span><span class=\"p\">],</span> <span class=\"o\">~</span><span class=\"n\">Y</span><span class=\"p\">]</span></span><span class=\"return-annotation\">) -> <span class=\"n\">streamAPI</span><span class=\"o\">.</span><span class=\"n\">stream</span><span class=\"o\">.</span><span class=\"n\">streamHelper</span><span class=\"o\">.</span><span class=\"n\">ChainedCondition</span>:</span></span>", "funcdef": "def"}, {"fullname": "streamAPI.stream.streamHelper.ChainedCondition.if_then", "modulename": "streamAPI.stream.streamHelper", "qualname": "ChainedCondition.if_then", "kind": "function", "doc": "<p>Creates _IfThen object from given \"if_\" and \"then\".</p>\n\n<h6 id=\"parameters\">Parameters</h6>\n\n<ul>\n<li><strong>if_</strong>: </li>\n<li><strong>then</strong>: </li>\n</ul>\n\n<h6 id=\"returns\">Returns</h6>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"bp\">self</span>, </span><span class=\"param\"><span class=\"n\">if_</span><span class=\"p\">:</span> <span class=\"n\">Callable</span><span class=\"p\">[[</span><span class=\"o\">~</span><span class=\"n\">X</span><span class=\"p\">],</span> <span class=\"nb\">bool</span><span class=\"p\">]</span>, </span><span class=\"param\"><span class=\"n\">then</span><span class=\"p\">:</span> <span class=\"n\">Callable</span><span class=\"p\">[[</span><span class=\"o\">~</span><span class=\"n\">X</span><span class=\"p\">],</span> <span class=\"o\">~</span><span class=\"n\">Y</span><span class=\"p\">]</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "streamAPI.stream.streamHelper.ChainedCondition.otherwise", "modulename": "streamAPI.stream.streamHelper", "qualname": "ChainedCondition.otherwise", "kind": "function", "doc": "<p>Adds \"else\" condition to ChainedCondition object.\nAfter this method, pipeline will be closed.</p>\n\n<p>It is required that \"if\" condition must be specified\nbefore invoking this method.</p>\n\n<h6 id=\"parameters\">Parameters</h6>\n\n<ul>\n<li><strong>else_</strong>: </li>\n</ul>\n\n<h6 id=\"returns\">Returns</h6>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"bp\">self</span>, </span><span class=\"param\"><span class=\"n\">else_</span><span class=\"p\">:</span> <span class=\"n\">Callable</span><span class=\"p\">[[</span><span class=\"o\">~</span><span class=\"n\">X</span><span class=\"p\">],</span> <span class=\"o\">~</span><span class=\"n\">Y</span><span class=\"p\">]</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "streamAPI.stream.streamHelper.ChainedCondition.done", "modulename": "streamAPI.stream.streamHelper", "qualname": "ChainedCondition.done", "kind": "function", "doc": "<p>closes the ChainedCondition pipeline.</p>\n\n<h6 id=\"returns\">Returns</h6>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"bp\">self</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "streamAPI.stream.streamHelper.ChainedCondition.apply", "modulename": "streamAPI.stream.streamHelper", "qualname": "ChainedCondition.apply", "kind": "function", "doc": "<p>Transforms given element using added conditions.</p>\n\n<p>If no condition returns True on element e then returns e.</p>\n\n<p>Note that ChainedCondition pipeline must be closed\nbefore invoking this method.</p>\n\n<h6 id=\"parameters\">Parameters</h6>\n\n<ul>\n<li><strong>e</strong>: </li>\n</ul>\n\n<h6 id=\"returns\">Returns</h6>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"bp\">self</span>, </span><span class=\"param\"><span class=\"n\">e</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "streamAPI.stream.streamHelper.ChainedCondition.default_name", "modulename": "streamAPI.stream.streamHelper", "qualname": "ChainedCondition.default_name", "kind": "function", "doc": "<p></p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"bp\">self</span></span><span class=\"return-annotation\">) -> <span class=\"nb\">str</span>:</span></span>", "funcdef": "def"}, {"fullname": "streamAPI.stream.streamHelper.Closable", "modulename": "streamAPI.stream.streamHelper", "qualname": "Closable", "kind": "class", "doc": "<p></p>\n"}, {"fullname": "streamAPI.stream.streamHelper.Closable.closed", "modulename": "streamAPI.stream.streamHelper", "qualname": "Closable.closed", "kind": "variable", "doc": "<p>Gets current state of pipeline.</p>\n\n<h6 id=\"returns\">Returns</h6>\n"}, {"fullname": "streamAPI.stream.streamHelper.Supplier", "modulename": "streamAPI.stream.streamHelper", "qualname": "Supplier", "kind": "class", "doc": "<p>This class provide a wrapper around a callable function.</p>\n\n<p>Example:\n    from random import random</p>\n\n<pre><code>supplier = Supplier(random)\n\nprint(next(supplier))\nprint(next(supplier))\nprint(next(supplier))\n\nfor idx, x in enumerate(supplier):\n    print(x)\n\n    if idx == 10:\n        break\n</code></pre>\n", "bases": "typing.Iterable[~X]"}, {"fullname": "streamAPI.stream.streamHelper.Supplier.__init__", "modulename": "streamAPI.stream.streamHelper", "qualname": "Supplier.__init__", "kind": "function", "doc": "<p></p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">func</span><span class=\"p\">:</span> <span class=\"n\">Callable</span><span class=\"p\">[[],</span> <span class=\"o\">~</span><span class=\"n\">X</span><span class=\"p\">]</span></span>)</span>"}, {"fullname": "streamAPI.testHelper", "modulename": "streamAPI.testHelper", "kind": "module", "doc": "<p>author: Shiv\nemail: shivkj001@gmail.com</p>\n"}, {"fullname": "streamAPI.testHelper.SEED", "modulename": "streamAPI.testHelper", "qualname": "SEED", "kind": "variable", "doc": "<p></p>\n", "default_value": "10"}, {"fullname": "streamAPI.testHelper.RND", "modulename": "streamAPI.testHelper", "qualname": "RND", "kind": "class", "doc": "<p>Random number generator base class used by bound module functions.</p>\n\n<p>Used to instantiate instances of Random to get generators that don't\nshare state.</p>\n\n<p>Class Random can also be subclassed if you want to use a different basic\ngenerator of your own devising: in that case, override the following\nmethods:  random(), seed(), getstate(), and setstate().\nOptionally, implement a getrandbits() method so that randrange()\ncan cover arbitrarily large ranges.</p>\n", "bases": "random.Random"}, {"fullname": "streamAPI.testHelper.RND.__init__", "modulename": "streamAPI.testHelper", "qualname": "RND.__init__", "kind": "function", "doc": "<p>Initialize an instance.</p>\n\n<p>Optional argument x controls seeding, as for Random.seed().</p>\n", "signature": "<span class=\"signature pdoc-code multiline\">(<span class=\"param\">\t<span class=\"n\">x</span><span class=\"o\">=</span><span class=\"kc\">None</span>,</span><span class=\"param\">\t<span class=\"n\">seed</span><span class=\"o\">=</span><span class=\"mi\">10</span>,</span><span class=\"param\">\t<span class=\"n\">version</span><span class=\"o\">=</span><span class=\"s1\">&#39;3.12.9 (main, Mar 17 2025, 21:36:21) [Clang 20.1.0 ]&#39;</span></span>)</span>"}, {"fullname": "streamAPI.testHelper.RND.reset", "modulename": "streamAPI.testHelper", "qualname": "RND.reset", "kind": "function", "doc": "<p></p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"bp\">self</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "streamAPI.testHelper.RND.int_range", "modulename": "streamAPI.testHelper", "qualname": "RND.int_range", "kind": "function", "doc": "<p></p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"bp\">self</span>, </span><span class=\"param\"><span class=\"n\">a</span>, </span><span class=\"param\"><span class=\"n\">b</span>, </span><span class=\"param\"><span class=\"n\">step</span><span class=\"o\">=</span><span class=\"mi\">1</span>, </span><span class=\"param\"><span class=\"o\">*</span>, </span><span class=\"param\"><span class=\"n\">size</span></span><span class=\"return-annotation\">) -> <span class=\"nb\">list</span>:</span></span>", "funcdef": "def"}, {"fullname": "streamAPI.testHelper.RND.float_range", "modulename": "streamAPI.testHelper", "qualname": "RND.float_range", "kind": "function", "doc": "<p></p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"bp\">self</span>, </span><span class=\"param\"><span class=\"n\">a</span>, </span><span class=\"param\"><span class=\"n\">b</span>, </span><span class=\"param\"><span class=\"n\">size</span></span><span class=\"return-annotation\">) -> <span class=\"nb\">list</span>:</span></span>", "funcdef": "def"}, {"fullname": "streamAPI.testHelper.RND.int_range_supplier", "modulename": "streamAPI.testHelper", "qualname": "RND.int_range_supplier", "kind": "function", "doc": "<p></p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"bp\">self</span>, </span><span class=\"param\"><span class=\"n\">a</span>, </span><span class=\"param\"><span class=\"n\">b</span>, </span><span class=\"param\"><span class=\"n\">step</span><span class=\"o\">=</span><span class=\"mi\">1</span></span><span class=\"return-annotation\">) -> <span class=\"n\">streamAPI</span><span class=\"o\">.</span><span class=\"n\">stream</span><span class=\"o\">.</span><span class=\"n\">streamHelper</span><span class=\"o\">.</span><span class=\"n\">Supplier</span>:</span></span>", "funcdef": "def"}, {"fullname": "streamAPI.testHelper.random", "modulename": "streamAPI.testHelper", "qualname": "random", "kind": "function", "doc": "<p></p>\n", "signature": "<span class=\"signature pdoc-code multiline\">(<span class=\"param\">\t<span class=\"n\">seed</span><span class=\"o\">=</span><span class=\"mi\">10</span>,</span><span class=\"param\">\t<span class=\"n\">version</span><span class=\"o\">=</span><span class=\"s1\">&#39;3.12.9 (main, Mar 17 2025, 21:36:21) [Clang 20.1.0 ]&#39;</span></span><span class=\"return-annotation\">) -> <span class=\"n\">streamAPI</span><span class=\"o\">.</span><span class=\"n\">testHelper</span><span class=\"o\">.</span><span class=\"n\">RND</span>:</span></span>", "funcdef": "def"}, {"fullname": "streamAPI.utility", "modulename": "streamAPI.utility", "kind": "module", "doc": "<p></p>\n"}, {"fullname": "streamAPI.utility.Types", "modulename": "streamAPI.utility.Types", "kind": "module", "doc": "<p>author: Shiv\nemail: shivkj001@gmail.com</p>\n"}, {"fullname": "streamAPI.utility.Types.Function", "modulename": "streamAPI.utility.Types", "qualname": "Function", "kind": "variable", "doc": "<p></p>\n", "default_value": "typing.Callable[[~X], ~Y]"}, {"fullname": "streamAPI.utility.Types.BiFunction", "modulename": "streamAPI.utility.Types", "qualname": "BiFunction", "kind": "variable", "doc": "<p></p>\n", "default_value": "typing.Callable[[~X, ~Y], ~Z]"}, {"fullname": "streamAPI.utility.Types.Consumer", "modulename": "streamAPI.utility.Types", "qualname": "Consumer", "kind": "variable", "doc": "<p></p>\n", "default_value": "typing.Callable[[~X], NoneType]"}, {"fullname": "streamAPI.utility.Types.Filter", "modulename": "streamAPI.utility.Types", "qualname": "Filter", "kind": "variable", "doc": "<p></p>\n", "default_value": "typing.Callable[[~X], bool]"}, {"fullname": "streamAPI.utility.Types.PathGenerator", "modulename": "streamAPI.utility.Types", "qualname": "PathGenerator", "kind": "variable", "doc": "<p></p>\n", "default_value": "typing.Iterable[str]"}, {"fullname": "streamAPI.utility.Types.DateTime", "modulename": "streamAPI.utility.Types", "qualname": "DateTime", "kind": "variable", "doc": "<p></p>\n", "default_value": "typing.Union[str, datetime.date, datetime.datetime]"}, {"fullname": "streamAPI.utility.utils", "modulename": "streamAPI.utility.utils", "kind": "module", "doc": "<p>author: Shiv\nemail: shivkj001@gmail.com</p>\n"}, {"fullname": "streamAPI.utility.utils.always_true", "modulename": "streamAPI.utility.utils", "qualname": "always_true", "kind": "function", "doc": "<p></p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">e</span></span><span class=\"return-annotation\">) -> <span class=\"nb\">bool</span>:</span></span>", "funcdef": "def"}, {"fullname": "streamAPI.utility.utils.as_date", "modulename": "streamAPI.utility.utils", "qualname": "as_date", "kind": "function", "doc": "<p>create date object from given \"date_\". If \"date_\" is of type string, then\nit must to of type \"YYYY-MM-DD\".</p>\n\n<h6 id=\"parameters\">Parameters</h6>\n\n<ul>\n<li><strong>date_</strong>: </li>\n</ul>\n\n<h6 id=\"returns\">Returns</h6>\n\n<blockquote>\n  <p>date object made from \"date_\"</p>\n</blockquote>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">date_</span><span class=\"p\">:</span> <span class=\"n\">Union</span><span class=\"p\">[</span><span class=\"nb\">str</span><span class=\"p\">,</span> <span class=\"n\">datetime</span><span class=\"o\">.</span><span class=\"n\">date</span><span class=\"p\">,</span> <span class=\"n\">datetime</span><span class=\"o\">.</span><span class=\"n\">datetime</span><span class=\"p\">]</span></span><span class=\"return-annotation\">) -> <span class=\"n\">datetime</span><span class=\"o\">.</span><span class=\"n\">date</span>:</span></span>", "funcdef": "def"}, {"fullname": "streamAPI.utility.utils.comparing", "modulename": "streamAPI.utility.utils", "qualname": "comparing", "kind": "function", "doc": "<p>returns \"default_comp\" but sets \"func\" kwarg using given input.</p>\n\n<h6 id=\"parameters\">Parameters</h6>\n\n<ul>\n<li><strong>func</strong>: </li>\n</ul>\n\n<h6 id=\"returns\">Returns</h6>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">func</span><span class=\"p\">:</span> <span class=\"n\">Callable</span><span class=\"p\">[[</span><span class=\"o\">~</span><span class=\"n\">X</span><span class=\"p\">],</span> <span class=\"o\">~</span><span class=\"n\">Y</span><span class=\"p\">]</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "streamAPI.utility.utils.csv_itr", "modulename": "streamAPI.utility.utils", "qualname": "csv_itr", "kind": "function", "doc": "<p>returns a generator from reading csv file.\nEach row is returned as dictionary.</p>\n\n<h6 id=\"parameters\">Parameters</h6>\n\n<ul>\n<li><strong>file</strong>: </li>\n<li><strong>as_dict</strong>: </li>\n</ul>\n\n<h6 id=\"returns\">Returns</h6>\n\n<blockquote>\n  <p>row of csv</p>\n</blockquote>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">file</span><span class=\"p\">:</span> <span class=\"nb\">str</span>, </span><span class=\"param\"><span class=\"n\">as_dict</span><span class=\"o\">=</span><span class=\"kc\">True</span></span><span class=\"return-annotation\">) -> <span class=\"n\">Iterable</span><span class=\"p\">[</span><span class=\"n\">Dict</span><span class=\"p\">[</span><span class=\"nb\">str</span><span class=\"p\">,</span> <span class=\"nb\">str</span><span class=\"p\">]]</span>:</span></span>", "funcdef": "def"}, {"fullname": "streamAPI.utility.utils.date_generator", "modulename": "streamAPI.utility.utils", "qualname": "date_generator", "kind": "function", "doc": "<p>generates dates between start and end date.</p>\n\n<p>Example:\n    for date_ in date_generator('2017-01-01','2017-01-10',include_end=False,interval=3):\n        print(date_,end=' ')\n    prints: 2017-01-01 2017-01-04 2017-01-07</p>\n\n<pre><code>for date_ in date_generator('2017-01-01','2017-01-10',include_end=True,interval=3):\n    print(date_,end=' ')\nprints: 2017-01-01 2017-01-04 2017-01-07 2017-01-10\n</code></pre>\n\n<h6 id=\"parameters\">Parameters</h6>\n\n<ul>\n<li><strong>start_date</strong>: </li>\n<li><strong>end_date</strong>: </li>\n<li><strong>include_end</strong>:  defaults to True</li>\n<li><strong>interval</strong>:  defaults to 1</li>\n</ul>\n\n<h6 id=\"returns\">Returns</h6>\n\n<blockquote>\n  <p>generator of date using given arguments.</p>\n</blockquote>\n", "signature": "<span class=\"signature pdoc-code multiline\">(<span class=\"param\">\t<span class=\"n\">start_date</span><span class=\"p\">:</span> <span class=\"n\">Union</span><span class=\"p\">[</span><span class=\"nb\">str</span><span class=\"p\">,</span> <span class=\"n\">datetime</span><span class=\"o\">.</span><span class=\"n\">date</span><span class=\"p\">,</span> <span class=\"n\">datetime</span><span class=\"o\">.</span><span class=\"n\">datetime</span><span class=\"p\">]</span>,</span><span class=\"param\">\t<span class=\"n\">end_date</span><span class=\"p\">:</span> <span class=\"n\">Union</span><span class=\"p\">[</span><span class=\"nb\">str</span><span class=\"p\">,</span> <span class=\"n\">datetime</span><span class=\"o\">.</span><span class=\"n\">date</span><span class=\"p\">,</span> <span class=\"n\">datetime</span><span class=\"o\">.</span><span class=\"n\">datetime</span><span class=\"p\">]</span>,</span><span class=\"param\">\t<span class=\"n\">include_end</span><span class=\"p\">:</span> <span class=\"nb\">bool</span> <span class=\"o\">=</span> <span class=\"kc\">True</span>,</span><span class=\"param\">\t<span class=\"n\">interval</span><span class=\"p\">:</span> <span class=\"nb\">int</span> <span class=\"o\">=</span> <span class=\"mi\">1</span></span><span class=\"return-annotation\">) -> <span class=\"n\">Iterable</span><span class=\"p\">[</span><span class=\"n\">datetime</span><span class=\"o\">.</span><span class=\"n\">date</span><span class=\"p\">]</span>:</span></span>", "funcdef": "def"}, {"fullname": "streamAPI.utility.utils.default_comp", "modulename": "streamAPI.utility.utils", "qualname": "default_comp", "kind": "function", "doc": "<p>compares 'a' and 'b'. (__lt__, __eq__ methods must be implemented by\ncorresponding 'class')</p>\n\n<p>1) If a is equal to b then returns 0\n2) If a is less than b then returns -1\n3) else return 1</p>\n\n<h6 id=\"parameters\">Parameters</h6>\n\n<ul>\n<li><strong>a</strong>: </li>\n<li><strong>b</strong>: </li>\n<li><strong>func</strong>:  if not None, then comparison is made on func(a) and func(b)</li>\n</ul>\n\n<h6 id=\"returns\">Returns</h6>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">a</span><span class=\"p\">:</span> <span class=\"o\">~</span><span class=\"n\">X</span>, </span><span class=\"param\"><span class=\"n\">b</span><span class=\"p\">:</span> <span class=\"o\">~</span><span class=\"n\">X</span>, </span><span class=\"param\"><span class=\"n\">func</span><span class=\"p\">:</span> <span class=\"n\">Callable</span><span class=\"p\">[[</span><span class=\"o\">~</span><span class=\"n\">X</span><span class=\"p\">],</span> <span class=\"o\">~</span><span class=\"n\">Y</span><span class=\"p\">]</span> <span class=\"o\">=</span> <span class=\"kc\">None</span></span><span class=\"return-annotation\">) -> <span class=\"nb\">int</span>:</span></span>", "funcdef": "def"}, {"fullname": "streamAPI.utility.utils.divide_in_chunk", "modulename": "streamAPI.utility.utils", "qualname": "divide_in_chunk", "kind": "function", "doc": "<p>divides list of elements in fixed size of chunks.\nLast chunk can have elements less than chunk_size.</p>\n\n<h6 id=\"parameters\">Parameters</h6>\n\n<ul>\n<li><strong>docs</strong>:  list of elements</li>\n<li><strong>chunk_size</strong>: </li>\n</ul>\n\n<h6 id=\"returns\">Returns</h6>\n\n<blockquote>\n  <p>generator for chunks</p>\n</blockquote>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">docs</span><span class=\"p\">:</span> <span class=\"n\">Iterable</span><span class=\"p\">[</span><span class=\"o\">~</span><span class=\"n\">T</span><span class=\"p\">]</span>, </span><span class=\"param\"><span class=\"n\">chunk_size</span><span class=\"p\">:</span> <span class=\"nb\">int</span></span><span class=\"return-annotation\">) -> <span class=\"n\">Iterable</span><span class=\"p\">[</span><span class=\"n\">Tuple</span><span class=\"p\">[</span><span class=\"o\">~</span><span class=\"n\">T</span><span class=\"p\">,</span> <span class=\"o\">...</span><span class=\"p\">]]</span>:</span></span>", "funcdef": "def"}, {"fullname": "streamAPI.utility.utils.filter_transform", "modulename": "streamAPI.utility.utils", "qualname": "filter_transform", "kind": "function", "doc": "<p>given a iterator filters elements using \"condition\" and transform filtered element using \"transform\".</p>\n\n<p>Example:\n    for e in filter_transform(range(10),lambda x:x%2==0,lambda x:x**2):\n        print(e,end=' ')</p>\n\n<pre><code>prints: 0 4 16 36 64\n</code></pre>\n\n<h6 id=\"parameters\">Parameters</h6>\n\n<ul>\n<li><strong>itr</strong>:  data source</li>\n<li><strong>condition</strong>:  filtering condition.</li>\n<li><strong>transform</strong>:  maps filtered elements.</li>\n</ul>\n\n<h6 id=\"returns\">Returns</h6>\n\n<blockquote>\n  <p>iterator made from first filtering and then transforming filtered elements.</p>\n</blockquote>\n", "signature": "<span class=\"signature pdoc-code multiline\">(<span class=\"param\">\t<span class=\"n\">itr</span><span class=\"p\">:</span> <span class=\"n\">Iterable</span><span class=\"p\">[</span><span class=\"o\">~</span><span class=\"n\">T</span><span class=\"p\">]</span>,</span><span class=\"param\">\t<span class=\"n\">condition</span><span class=\"p\">:</span> <span class=\"n\">Callable</span><span class=\"p\">[[</span><span class=\"o\">~</span><span class=\"n\">T</span><span class=\"p\">],</span> <span class=\"nb\">bool</span><span class=\"p\">]</span>,</span><span class=\"param\">\t<span class=\"n\">transform</span><span class=\"p\">:</span> <span class=\"n\">Callable</span><span class=\"p\">[[</span><span class=\"o\">~</span><span class=\"n\">T</span><span class=\"p\">],</span> <span class=\"o\">~</span><span class=\"n\">X</span><span class=\"p\">]</span></span><span class=\"return-annotation\">) -> <span class=\"n\">Iterable</span><span class=\"p\">[</span><span class=\"o\">~</span><span class=\"n\">X</span><span class=\"p\">]</span>:</span></span>", "funcdef": "def"}, {"fullname": "streamAPI.utility.utils.get_chunk", "modulename": "streamAPI.utility.utils", "qualname": "get_chunk", "kind": "function", "doc": "<p>fetching one chunk from itr using rng class object.\nIn case, rng is an integer, it is converted as rng = range(rng)</p>\n\n<p>Returned chunk size will be minimum of itr size and chunk size.</p>\n\n<p>Note that: rng size can not be zero. If rng is not of type range then\n           it must be of type int which will represent chunk size and\n           it should be positive.</p>\n\n<h6 id=\"parameters\">Parameters</h6>\n\n<ul>\n<li><strong>itr</strong>: </li>\n<li><strong>rng</strong>:  defines chunk size</li>\n<li><strong>return_type</strong>: </li>\n</ul>\n\n<h6 id=\"returns\">Returns</h6>\n", "signature": "<span class=\"signature pdoc-code multiline\">(<span class=\"param\">\t<span class=\"n\">itr</span><span class=\"p\">:</span> <span class=\"n\">Iterable</span><span class=\"p\">[</span><span class=\"o\">~</span><span class=\"n\">T</span><span class=\"p\">]</span>,</span><span class=\"param\">\t<span class=\"n\">rng</span><span class=\"p\">:</span> <span class=\"n\">Union</span><span class=\"p\">[</span><span class=\"nb\">range</span><span class=\"p\">,</span> <span class=\"nb\">int</span><span class=\"p\">]</span>,</span><span class=\"param\">\treturn_type: Callable[[Iterable[~X]], ~Y] = &lt;class &#x27;tuple&#x27;&gt;</span><span class=\"return-annotation\">) -> <span class=\"o\">~</span><span class=\"n\">Y</span>:</span></span>", "funcdef": "def"}, {"fullname": "streamAPI.utility.utils.get_functions_clazz", "modulename": "streamAPI.utility.utils", "qualname": "get_functions_clazz", "kind": "function", "doc": "<p>returns collection of function and class in a module not starting with '_'</p>\n\n<h6 id=\"parameters\">Parameters</h6>\n\n<ul>\n<li><strong>module_name</strong>:  __name__</li>\n<li><strong>script_path</strong>: __file__</li>\n</ul>\n\n<h6 id=\"returns\">Returns</h6>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">module_name</span><span class=\"p\">:</span> <span class=\"nb\">str</span>, </span><span class=\"param\"><span class=\"n\">script_path</span><span class=\"p\">:</span> <span class=\"nb\">str</span></span><span class=\"return-annotation\">) -> <span class=\"nb\">tuple</span>:</span></span>", "funcdef": "def"}, {"fullname": "streamAPI.utility.utils.identity", "modulename": "streamAPI.utility.utils", "qualname": "identity", "kind": "function", "doc": "<p></p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">e</span><span class=\"p\">:</span> <span class=\"o\">~</span><span class=\"n\">T</span></span><span class=\"return-annotation\">) -> <span class=\"o\">~</span><span class=\"n\">T</span>:</span></span>", "funcdef": "def"}, {"fullname": "streamAPI.utility.utils.csv_ListReader", "modulename": "streamAPI.utility.utils", "qualname": "csv_ListReader", "kind": "variable", "doc": "<p></p>\n", "annotation": ": Callable[[str], Iterable[List[str]]]", "default_value": "functools.partial(&lt;function csv_itr&gt;, as_dict=False)"}];

    // mirrored in build-search-index.js (part 1)
    // Also split on html tags. this is a cheap heuristic, but good enough.
    elasticlunr.tokenizer.setSeperator(/[\s\-.;&_'"=,()]+|<[^>]*>/);

    let searchIndex;
    if (docs._isPrebuiltIndex) {
        console.info("using precompiled search index");
        searchIndex = elasticlunr.Index.load(docs);
    } else {
        console.time("building search index");
        // mirrored in build-search-index.js (part 2)
        searchIndex = elasticlunr(function () {
            this.pipeline.remove(elasticlunr.stemmer);
            this.pipeline.remove(elasticlunr.stopWordFilter);
            this.addField("qualname");
            this.addField("fullname");
            this.addField("annotation");
            this.addField("default_value");
            this.addField("signature");
            this.addField("bases");
            this.addField("doc");
            this.setRef("fullname");
        });
        for (let doc of docs) {
            searchIndex.addDoc(doc);
        }
        console.timeEnd("building search index");
    }

    return (term) => searchIndex.search(term, {
        fields: {
            qualname: {boost: 4},
            fullname: {boost: 2},
            annotation: {boost: 2},
            default_value: {boost: 2},
            signature: {boost: 2},
            bases: {boost: 2},
            doc: {boost: 1},
        },
        expand: true
    });
})();